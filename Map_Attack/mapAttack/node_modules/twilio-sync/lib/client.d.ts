/// <reference types="node" />
import { EventEmitter } from 'events';
import { SyncDocument } from './syncdocument';
import { SyncList } from './synclist';
import { SyncMap } from './syncmap';
import { SyncStream } from './streams/syncstream';
declare type json = {
    [key: string]: any;
};
declare type OpenMode = 'open_or_create' | 'open_existing' | 'create_new';
interface OpenOptions {
    id?: string;
    mode?: OpenMode;
    ttl?: number;
}
interface OpenDocumentOptions extends OpenOptions {
    value?: json;
}
interface OpenListOptions extends OpenOptions {
    purpose?: string;
    context?: json;
    includeItems?: boolean;
}
interface OpenMapOptions extends OpenOptions {
    includeItems?: boolean;
}
interface OpenStreamOptions extends OpenOptions {
}
export declare type ConnectionState = 'disconnected' | 'connecting' | 'connected' | 'disconnecting' | 'denied' | 'error';
/**
 * @class Client
 * @classdesc
 * Client for the Twilio Sync service.
 * @constructor
 * @param {String} token - Twilio access token.
 * @param {Client#ClientOptions} [options] - Options to customize the Client.
 * @example
 * // Using NPM
 * var SyncClient = require('twilio-sync');
 * var syncClient = new SyncClient(token, { logLevel: 'debug' });
 *
 * // Using CDN
 * var SyncClient = new Twilio.Sync.Client(token, { logLevel: 'debug' });
 *
 * @property {Client#ConnectionState} connectionState - Contains current service connection state.
 * Valid options are ['connecting', 'connected', 'disconnecting', 'disconnected', 'denied', 'error'].
 */
declare class Client extends EventEmitter {
    private readonly services;
    private readonly entities;
    private readonly productId;
    private fpaToken;
    private localStorageId;
    private readonly authData;
    constructor(fpaToken: string, options?: any);
    /**
     * Current version of Sync client.
     * @name Client#version
     * @type String
     * @readonly
     */
    static readonly version: any;
    readonly connectionState: ConnectionState;
    private handleEmsResponse(response);
    /**
     * Returns promise which resolves when library is correctly initialized
     * Or throws if initialization is impossible
     * @private
     */
    private ensureReady();
    private storeRootInSessionCache(type, id, value);
    private readRootFromSessionCache(type, id);
    private _get(baseUri, id, optimistic?);
    private _createDocument(id, data?, ttl?);
    private _getDocument(id);
    private _createList(id, purpose?, context?, ttl?);
    private _getList(id);
    private _createMap(id, ttl?);
    private _getMap(id, optimistic?);
    private _getStream(id);
    private _createStream(id, ttl?);
    private getCached<T>(id, type);
    private removeFromCacheAndSession(type, sid, uniqueName);
    /**
     * Read or create a Sync Document.
     * @param {String | Client#OpenOptions} [arg] One of:
     * <li>Unique name or SID identifying a Sync Document - opens a Document with the given identifier or creates one if it does not exist.</li>
     * <li>none - creates a new Document with a randomly assigned SID and no unique name.</li>
     * <li>{@link Client#OpenOptions} object for more granular control.</li>
     * @return {Promise<Document>} a promise which resolves after the Document is successfully read (or created).
     * This promise may reject if the Document could not be created or if this endpoint lacks the necessary permissions to access it.
     * @public
     * @example
     * syncClient.document('MyDocument')
     *   .then(function(document) {
     *     console.log('Successfully opened a Document. SID: ' + document.sid);
     *     document.on('updated', function(event) {
     *       console.log('Received updated event: ', event);
     *     });
     *   })
     *   .catch(function(error) {
     *     console.log('Unexpected error', error);
     *   });
     */
    document(arg?: string | OpenDocumentOptions): Promise<SyncDocument>;
    /**
     * Read or create a Sync Map.
     * @param {String | Client#OpenOptions} [arg] One of:
     * <li>Unique name or SID identifying a Sync Map - opens a Map with the given identifier or creates one if it does not exist.</li>
     * <li>none - creates a new Map with a randomly assigned SID and no unique name.</li>
     * <li>{@link Client#OpenOptions} object for more granular control.</li>
     * @return {Promise<Map>} a promise which resolves after the Map is successfully read (or created).
     * This promise may reject if the Map could not be created or if this endpoint lacks the necessary permissions to access it.
     * @public
     * @example
     * syncClient.map('MyMap')
     *   .then(function(map) {
     *     console.log('Successfully opened a Map. SID: ' + map.sid);
     *     map.on('itemUpdated', function(event) {
     *       console.log('Received itemUpdated event: ', event);
     *     });
     *   })
     *   .catch(function(error) {
     *     console.log('Unexpected error', error);
     *   });
     */
    map(arg?: string | OpenMapOptions): Promise<SyncMap>;
    /**
     * Read or create a Sync List.
     * @param {String | Client#OpenOptions} [arg] One of:
     * <li>Unique name or SID identifying a Sync List - opens a List with the given identifier or creates one if it does not exist.</li>
     * <li>none - creates a new List with a randomly assigned SID and no unique name.</li>
     * <li>{@link Client#OpenOptions} object for more granular control.</li>
     * @return {Promise<List>} a promise which resolves after the List is successfully read (or created).
     * This promise may reject if the List could not be created or if this endpoint lacks the necessary permissions to access it.
     * @public
     * @example
     * syncClient.list('MyList')
     *   .then(function(list) {
     *     console.log('Successfully opened a List. SID: ' + list.sid);
     *     list.on('itemAdded', function(event) {
     *       console.log('Received itemAdded event: ', event);
     *     });
     *   })
     *   .catch(function(error) {
     *     console.log('Unexpected error', error);
     *   });
     */
    list(arg?: string | OpenListOptions): Promise<SyncList>;
    /**
     * Read or create a Sync Message Stream.
     * @param {String | Client#OpenOptions} [arg] One of:
     * <li>Unique name or SID identifying a Stream - opens a Stream with the given identifier or creates one if it does not exist.</li>
     * <li>none - creates a new Stream with a randomly assigned SID and no unique name.</li>
     * <li>{@link Client#OpenOptions} object for more granular control.</li>
     * @return {Promise<Stream>} a promise which resolves after the Stream is successfully read (or created).
     * The flow of messages will begin imminently (but not necessarily immediately) upon resolution.
     * This promise may reject if the Stream could not be created or if this endpoint lacks the necessary permissions to access it.
     * @public
     * @example
     * syncClient.stream('MyStream')
     *   .then(function(stream) {
     *     console.log('Successfully opened a Message Stream. SID: ' + stream.sid);
     *     stream.on('messagePublished', function(event) {
     *       console.log('Received messagePublished event: ', event);
     *     });
     *   })
     *   .catch(function(error) {
     *     console.log('Unexpected error', error);
     *   });
     */
    stream(arg?: string | OpenStreamOptions): Promise<SyncStream>;
    /**
     * Gracefully shutdown the libray
     * Currently it is not properly implemented and being used only in tests
     * But should be made a part of public API
     * @private
     */
    shutdown(): Promise<void>;
    /**
     * Set new authentication token.
     * @param {String} token New token to set.
     * @return {Promise<void>}
     * @public
     */
    updateToken(token: string): Promise<void>;
}
export { Client, Client as SyncClient, OpenMode, json, OpenOptions, OpenDocumentOptions, OpenMapOptions, OpenListOptions, OpenStreamOptions };
export default Client;
