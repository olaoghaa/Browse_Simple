/// <reference types="node" />
import { EventEmitter } from 'events';
import { Member } from './member';
import { Message } from './message';
import { UserDescriptor } from './userdescriptor';
import { Users } from './data/users';
import { Paginator } from './interfaces/paginator';
import { Channels } from './data/channels';
import { McsClient } from 'twilio-mcs-client';
import * as FormData from 'isomorphic-form-data';
import { SyncClient } from 'twilio-sync';
import { Session } from './session';
import { ConsumptionHorizon } from './services/consumptionhorizon';
import { TypingIndicator } from './services/typingindicator';
import { Network } from './services/network';
declare function filterStatus(status: any): any;
export interface ChannelServices {
    session: Session;
    users: Users;
    typingIndicator: TypingIndicator;
    consumptionHorizon: ConsumptionHorizon;
    network: Network;
    mcsClient: McsClient;
    syncClient: SyncClient;
}
interface ChannelDescriptor {
    name: string;
    channel: string;
    entityName: string;
    uniqueName: string;
    attributes: Object;
    createdBy: string;
    friendlyName: string;
    lastConsumedMessageIndex: number;
    dateCreated: any;
    dateUpdated: any;
    type: Channel.Type;
}
export interface SendMediaOptions {
    contentType: string;
    media: string | Buffer;
}
/**
 * @classdesc A Channel represents a remote channel of communication between
 * multiple Programmable Chat Clients
 * @property {Object} attributes - The Channel's custom attributes
 * @property {String} createdBy - The identity of the User that created this Channel
 * @property {Date} dateCreated - The Date this Channel was created
 * @property {Date} dateUpdated - The Date this Channel was last updated
 * @property {String} friendlyName - The Channel's name
 * @property {Boolean} isPrivate - Whether the channel is private (as opposed to public)
 * @property {Number} lastConsumedMessageIndex - Index of the last Message the User has consumed in this Channel
 * @property {String} sid - The Channel's unique system identifier
 * @property {('unknown' | 'known' | 'invited' | 'joined' | 'failed')} status - Whether the Channel
 * is 'known' to local Client, Client is 'invited' to or is 'joined' to this Channel
 * @property {('public' | 'private')} type - The Channel's type as a String: ['private', 'public']
 * @property {String} uniqueName - The Channel's unique name (tag)
 * @fires Channel#memberJoined
 * @fires Channel#memberLeft
 * @fires Channel#memberUpdated
 * @fires Channel#messageAdded
 * @fires Channel#messageRemoved
 * @fires Channel#messageUpdated
 * @fires Channel#typingEnded
 * @fires Channel#typingStarted
 * @fires Channel#updated
 */
declare class Channel extends EventEmitter {
    readonly sid: string;
    private services;
    private state;
    private statusSource;
    private entityPromise;
    private entityName;
    private entity;
    private messagesEntity;
    private membersEntity;
    private members;
    constructor(services: ChannelServices, descriptor: ChannelDescriptor, sid: string);
    readonly status: Channel.Status;
    readonly type: Channel.Type;
    readonly uniqueName: string;
    readonly isPrivate: boolean;
    readonly friendlyName: string;
    readonly dateUpdated: any;
    readonly dateCreated: any;
    readonly createdBy: string;
    readonly attributes: Object;
    readonly lastConsumedMessageIndex: number;
    /**
     * Load and Subscribe to this Channel and do not subscribe to its Members and Messages.
     * This or _subscribeStreams will need to be called before any events on Channel will fire.
     * @returns {Promise}
     * @private
     */
    _subscribe(): any;
    /**
     * Load the attributes of this Channel and instantiate its Members and Messages.
     * This or _subscribe will need to be called before any events on Channel will fire.
     * This will need to be called before any events on Members or Messages will fire
     * @returns {Promise}
     * @private
     */
    _subscribeStreams(): Promise<void>;
    /**
     * Stop listening for and firing events on this Channel.
     * @returns {Promise}
     * @private
     */
    _unsubscribe(): Promise<[any, any]>;
    /**
     * Set channel status
     * @private
     */
    _setStatus(status: Channel.Status, source: Channels.DataSource): void;
    /**
     * If channel's status update source
     * @private
     * @return {Channels.DataSource}
     */
    _statusSource(): Channels.DataSource;
    private static preprocessUpdate(update, channelSid);
    /**
     * Updates local channel object with new values
     * @private
     */
    _update(update: any): void;
    /**
     * @private
     */
    private _onMessageAdded(message);
    /**
     * Add a participant to the Channel by its Identity.
     * @param {String} identity - Identity of the Client to add
     * @returns {Promise<void|Error|SessionError>}
     */
    add(identity: string): Promise<any>;
    /**
     * Advance last consumed Channel's Message index to current consumption horizon.
     * Rejects if User is not Member of Channel.
     * Last consumed Message index is updated only if new index value is higher than previous.
     * @param {Number} index - Message index to advance to as last read
     * @returns {Promise<number|Error|SessionError>} resulting unread messages count in the channel
     */
    advanceLastConsumedMessageIndex(index: number): Promise<number>;
    /**
     * Decline an invitation to the Channel and unsubscribe from its events.
     * @returns {Promise<Channel|SessionError>}
     */
    decline(): Promise<Channel>;
    /**
     * Delete the Channel and unsubscribe from its events.
     * @returns {Promise<Channel|SessionError>}
     */
    delete(): Promise<Channel>;
    /**
     * Get the custom attributes of this Channel.<br/>
     *
     * <i>NOTE: {@link Channel}'s <code>attributes</code> property will be empty for public channels until this function is called.</i>
     * @returns {Promise<Object>}
     */
    getAttributes(): Promise<Object>;
    /**
     * Returns messages from channel using paginator interface.
     * @param {Number} [pageSize=30] Number of messages to return in single chunk
     * @param {Number} [anchor] - Index of newest Message to fetch. From the end by default
     * @param {String} [direction=backwards] - Query direction. By default it query backwards
     *                                         from newer to older. 'forward' will query in opposite direction
     * @returns {Promise<Paginator<Message>>} page of messages
     */
    getMessages(pageSize?: number, anchor?: number, direction?: string): Promise<Paginator<Message>>;
    /**
     * Get a list of all Members joined to this Channel.
     * @returns {Promise<Array<Member>>}
     */
    getMembers(): Promise<Array<Member>>;
    /**
     * Get channel members count.
     * @returns {Promise<number>}
     */
    getMembersCount(): Promise<number>;
    /**
     * Get total message count in a channel.
     * @returns {Promise<number>}
     */
    getMessagesCount(): Promise<number>;
    /**
     * Get unconsumed messages count for User if he is Member of this Channel.
     * Rejects if User is not Member of Channel.
     * @returns {Promise<number>}
     */
    getUnconsumedMessagesCount(): Promise<number>;
    /**
     * Invite a user to the Channel by their Identity.
     * @param {String} identity - Identity of the user to invite
     * @returns {Promise<void|Error|SessionError>}
     */
    invite(identity: string): Promise<void>;
    /**
     * Join the Channel and subscribe to its events.
     * @returns {Promise<Channel|SessionError>}
     */
    join(): Promise<Channel>;
    /**
     * Leave the Channel.
     * @returns {Promise<Channel|SessionError>}
     */
    leave(): Promise<Channel>;
    /**
     * Remove a Member from the Channel.
     * @param {String} member - identity of member to remove
     * @returns {Promise<void|Error|SessionError>}
     */
    removeMember(member: any): Promise<void>;
    /**
     * Send a Message in the Channel.
     * @param {String | FormData | Channel#SendMediaOptions} message - The message body for text message,
     * FormData or MediaOptions for media content
     * @param {Object} messageAttributes - attributes for the message
     * @returns {Promise<String>}
     */
    sendMessage(message: string | FormData | SendMediaOptions, messageAttributes?: Object): Promise<string>;
    /**
     * These options can be passed to {@link Channel#sendMessage}.
     * @typedef {Object} Channel#SendMediaOptions
     * @property {String} contentType - content type of media
     * @property {String | Buffer} media - content to post
     */
    /**
     * Set last consumed Channel's Message index to last known Message's index in this Channel.
     * @returns {Promise<number>} resulting unread messages count in the channel
     */
    setAllMessagesConsumed(): Promise<number>;
    /**
     * Set all messages in the channel unread.
     * @returns {Promise<number>} resulting unread messages count in the channel
     */
    setNoMessagesConsumed(): Promise<number>;
    /**
     * Send a notification to the server indicating that this Client is currently typing in this Channel.
     * Typing ended notification is sent after a while automatically, but by calling again this method you ensure typing ended is not received.
     * @returns {Promise<void|SessionError>}
     */
    typing(): any;
    /**
     * Update the Channel's attributes.
     * @param {Object} attributes - The new attributes object
     * @returns {Promise<Channel|Error|SessionError>}
     */
    updateAttributes(attributes: Object): Promise<this>;
    /**
     * Update the Channel's friendlyName.
     * @param {String} name - The new Channel friendlyName
     * @returns {Promise<Channel|SessionError>}
     */
    updateFriendlyName(name: string): Promise<this>;
    /**
     * Set last consumed Channel's Message index to current consumption horizon.
     * @param {Number|null} index - Message index to set as last read.
     * If null provided, then the behavior is identical to {@link Channel#setNoMessagesConsumed}
     * @returns {Promise<number|Error|SessionError>} resulting unread messages count in the channel
     */
    updateLastConsumedMessageIndex(index: number): Promise<number>;
    /**
     * Update the Channel's unique name.
     * @param {String} uniqueName - The new Channel uniqueName
     * @returns {Promise<Channel|SessionError>}
     */
    updateUniqueName(uniqueName: string): Promise<Channel>;
    /**
     * Gets User Descriptors for this channel.
     * @returns {Promise<Paginator<UserDescriptor>>}
     */
    getUserDescriptors(): Promise<Paginator<UserDescriptor>>;
}
/**
 * The type of Channel (Public or private).
 * @readonly
 * @enum {String}
 */
declare namespace Channel {
    type Type = 'public' | 'private';
}
/**
 * The status of the Channel, relative to the Client.
 * @readonly
 * @enum {String}
 */
declare namespace Channel {
    type Status = 'unknown' | 'known' | 'invited' | 'joined' | 'failed';
}
export { ChannelDescriptor, Channel, filterStatus };
