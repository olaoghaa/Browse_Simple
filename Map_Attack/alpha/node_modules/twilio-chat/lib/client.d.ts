/// <reference types="node" />
import { EventEmitter } from 'events';
import { User } from './user';
import * as TwilsockClient from 'twilsock';
import * as NotificationClient from 'twilio-notifications';
import { Transport } from 'twilio-transport';
import { SyncClient } from 'twilio-sync';
import { EmsClient } from 'twilio-ems-client';
import { Channel } from './data/channels';
import { UserDescriptor } from './userdescriptor';
import { ChannelDescriptor } from './channeldescriptor';
import { Paginator } from './interfaces/paginator';
import { PushNotification } from './pushnotification';
export declare type LogLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'silent' | null;
export declare type ConnectionState = 'disconnected' | 'disconnecting' | 'connected' | 'connecting' | 'error' | 'denied';
export interface Options {
    realm?: string;
    logLevel?: LogLevel;
    productId?: string;
    twilsockClient?: TwilsockClient;
    transport?: Transport;
    emsClient?: EmsClient;
    notificationsClient?: NotificationClient;
    syncClient?: SyncClient;
    typingIndicatorTimeoutOverride?: number;
    consumptionReportIntervalOverride?: string;
    httpCacheIntervalOverride?: string;
    userInfosToSubscribeOverride?: number;
    retryWhenThrottledOverride?: boolean;
    backoffConfigOverride?: any;
    Chat?: any;
    Sync?: any;
    Notification?: any;
    Twilsock?: any;
}
/**
 * A Client is a starting point to access Twilio Programmable Chat functionality.
 *
 * @property {Map<sid, Channel>} channels - A Map containing all Channels known locally on
 *   the Client. Use {@link Client#getSubscribedChannels} too ensure Channels have loaded before getting a response
 * @property {Client#ConnectionState} connectionState - Client connection state
 * @property {Boolean} reachabilityEnabled - Client reachability state
 * @property {User} user - Information for logged in user
 * @property {String} version - Current version of Chat client
 *
 * @fires Client#connectionStateChanged
 * @fires Client#channelAdded
 * @fires Client#channelInvited
 * @fires Client#channelJoined
 * @fires Client#channelLeft
 * @fires Client#channelRemoved
 * @fires Client#channelUpdated
 * @fires Client#memberJoined
 * @fires Client#memberLeft
 * @fires Client#memberUpdated
 * @fires Client#messageAdded
 * @fires Client#messageRemoved
 * @fires Client#messageUpdated
 * @fires Client#pushNotification
 * @fires Client#typingEnded
 * @fires Client#typingStarted
 * @fires Client#userSubscribed
 * @fires Client#userUnsubscribed
 * @fires Client#userUpdated
 */
declare class Client extends EventEmitter {
    connectionState: ConnectionState;
    private sessionPromise;
    private channelsPromise;
    private fpaToken;
    private config;
    private channels;
    private options;
    private services;
    static readonly version: string;
    readonly version: string;
    private static readonly supportedPushChannels;
    private static readonly supportedPushDataFields;
    private constructor();
    /**
     * Factory method to create Chat client instance.
     *
     * @param {String} token - Access token
     * @param {Client#ClientOptions} options - Options to customize the Client
     * @returns {Promise<Client>}
     */
    static create(token: string, options?: Options): Promise<Client>;
    /**
     * These options can be passed to Client constructor.
     * @typedef {Object} Client#ClientOptions
     * @property {String} [logLevel='error'] - The level of logging to enable. Valid options
     *   (from strictest to broadest): ['silent', 'error', 'warn', 'info', 'debug', 'trace']
     */
    /**
     * Connection state of Client.
     * @typedef {('disconnected'|'disconnecting'|'connecting'|'connected'|'error'|'denied')} Client#ConnectionState
     */
    readonly user: User;
    readonly reachabilityEnabled: boolean;
    readonly token: string;
    private subscribeToPushNotifications(channelType);
    private initialize();
    /**
     * Gracefully shutting down library instance.
     * @public
     * @returns {Promise<void>}
     */
    shutdown(): Promise<void>;
    /**
     * Update the token used by the Client and re-register with Programmable Chat services.
     * @param {String} token - Access token
     * @public
     * @returns {Promise<Client>}
     */
    updateToken(token: string): Promise<Client>;
    /**
     * Get a known Channel by its SID.
     * @param {String} channelSid - Channel sid
     * @returns {Promise<Channel>}
     */
    getChannelBySid(channelSid: string): Promise<Channel>;
    /**
     * Get a known Channel by its unique identifier name.
     * @param {String} uniqueName - The unique identifier name of the Channel to get
     * @returns {Promise<Channel>}
     */
    getChannelByUniqueName(uniqueName: string): Promise<Channel>;
    /**
     * Get the current list of all subscribed Channels.
     * @returns {Promise<Paginator<Channel>>}
     */
    getSubscribedChannels(args: any): Promise<Paginator<Channel>>;
    /**
     * Get the public channels directory content.
     * @returns {Promise<Paginator<ChannelDescriptor>>}
     */
    getPublicChannelDescriptors(): Promise<Paginator<ChannelDescriptor>>;
    /**
     * Get the User's (created by, joined or invited to) channels directory content.
     * @returns {Promise<Paginator<ChannelDescriptor>>}
     */
    getUserChannelDescriptors(): Promise<Paginator<ChannelDescriptor>>;
    /**
     * Create a Channel on the server and subscribe to its events.
     * Default options are public Channel type with empty uniqueName and friendlyName.
     * @param {Client#CreateChannelOptions} [options] - Options for the Channel
     * @returns {Promise<Channel>}
     */
    createChannel(options: any): Promise<Channel>;
    /**
     * These options can be passed to {@link Client#createChannel}.
     * @typedef {Object} Client#CreateChannelOptions
     * @property {Object} [attributes] - Any custom attributes to attach to the Channel
     * @property {String} [friendlyName] - The non-unique display name of the Channel
     * @property {Boolean} [isPrivate] - Whether or not this Channel should be visible to uninvited Clients
     * @property {String} [uniqueName] - The unique identity name of the Channel
     */
    /**
     * Registers for push notifications.
     * @param {string} channelType - 'gcm', 'apn' and 'fcm' are supported
     * @param {string} registrationId - Push notification id provided by platform
     */
    setPushRegistrationId(channelType: string, registrationId: any): void;
    private static parsePushNotificationChatData(data);
    /**
     * Static method for push notification payload parsing. Returns parsed push as {@link PushNotification} object
     * @param {Object} notificationPayload - Push notification payload
     * @returns {PushNotification|Error}
     */
    static parsePushNotification(notificationPayload: any): PushNotification;
    parsePushNotification: typeof Client.parsePushNotification;
    /**
     * Handle push notification payload parsing and emits event {@link Client#event:pushNotification} on this {@link Client} instance.
     * @param {Object} notificationPayload - Push notification payload
     * @returns {void|Error}
     */
    handlePushNotification(notificationPayload: any): Promise<void>;
    /**
     * Gets user for given identity, if it's in subscribed list - then return the user object from it,
     * if not - then subscribes and adds user to the subscribed list.
     * @param {String} identity - Identity of User
     * @returns {Promise<User>} Fully initialized user
     */
    getUser(identity: string): Promise<User>;
    /**
     * Gets user descriptor for given identity.
     * @param {String} identity - Identity of User
     * @returns {Promise<UserDescriptor>} User descriptor
     */
    getUserDescriptor(identity: string): Promise<UserDescriptor>;
    /**
     * @returns {Promise<Array<User>>} List of subscribed User objects
     */
    getSubscribedUsers(): Promise<Array<User>>;
}
export { User, Client, PushNotification };
export default Client;
