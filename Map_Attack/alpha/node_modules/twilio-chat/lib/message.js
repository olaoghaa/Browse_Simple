"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const index_1 = require("./util/index");
const logger_1 = require("./logger");
const media_1 = require("./media");
const log = new logger_1.Logger();
function parseAttributes(msgSid, attributes) {
    try {
        return attributes ? JSON.parse(attributes) : {};
    }
    catch (e) {
        log.warn('Got malformed attributes for the message', msgSid);
        return {};
    }
}
/**
 * @classdesc A Message represents a Message in a Channel.
 * @property {String} author - The name of the user that sent Message
 * @property {String} body - The body of the Message. Is null if Message is Media Message
 * @property {Object} attributes - Message custom attributes
 * @property {Channel} channel - Channel Message belongs to
 * @property {Date} dateUpdated - When Message was updated
 * @property {Number} index - Index of Message in the Channel's messages list
 * @property {String} lastUpdatedBy - Identity of the last user that updated Message
 * @property {Media} media - Contains Media information (if present)
 * @property {String} sid - The server-assigned unique identifier for Message
 * @property {Date} timestamp - When Message was created
 * @property {'text' | 'media' } type - Type of message: 'text' or 'media'
 * @fires Message#updated
 */
class Message extends events_1.EventEmitter {
    constructor(channel, services, index, data) {
        super();
        this.channel = channel;
        this.services = services;
        this.state = {
            sid: data.sid,
            index: index,
            author: data.author,
            body: data.text,
            timestamp: data.timestamp ? new Date(data.timestamp) : null,
            dateUpdated: data.dateUpdated ? new Date(data.dateUpdated) : null,
            lastUpdatedBy: data.lastUpdatedBy ? data.lastUpdatedBy : null,
            attributes: parseAttributes(data.sid, data.attributes),
            type: data.type ? data.type : 'text',
            media: (data.type && data.type === 'media' && data.media)
                ? new media_1.Media(data.media, this.services) : null
        };
    }
    get sid() { return this.state.sid; }
    get author() { return this.state.author; }
    get body() {
        if (this.type === 'media') {
            return null;
        }
        return this.state.body;
    }
    get dateUpdated() { return this.state.dateUpdated; }
    get index() { return this.state.index; }
    get lastUpdatedBy() { return this.state.lastUpdatedBy; }
    get timestamp() { return this.state.timestamp; }
    get attributes() { return this.state.attributes; }
    get type() { return this.state.type; }
    get media() { return this.state.media; }
    _update(data) {
        let updated = false;
        if ((data.text || ((typeof data.text) === 'string')) && data.text !== this.state.body) {
            this.state.body = data.text;
            updated = true;
        }
        if (data.lastUpdatedBy && data.lastUpdatedBy !== this.state.lastUpdatedBy) {
            this.state.lastUpdatedBy = data.lastUpdatedBy;
            updated = true;
        }
        if (data.dateUpdated &&
            new Date(data.dateUpdated).getTime() !== (this.state.dateUpdated && this.state.dateUpdated.getTime())) {
            this.state.dateUpdated = new Date(data.dateUpdated);
            updated = true;
        }
        if (data.timestamp &&
            new Date(data.timestamp).getTime() !== (this.state.timestamp && this.state.timestamp.getTime())) {
            this.state.timestamp = new Date(data.timestamp);
            updated = true;
        }
        let updatedAttributes = parseAttributes(this.sid, data.attributes);
        if (!index_1.isDeepEqual(this.state.attributes, updatedAttributes)) {
            this.state.attributes = updatedAttributes;
            updated = true;
        }
        if (updated) {
            this.emit('updated', this);
        }
    }
    /**
     * Remove the Message.
     * @returns {Promise<Message|SessionError>}
     */
    remove() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.services.session.addCommand('deleteMessage', {
                channelSid: this.channel.sid,
                messageIdx: this.index.toString()
            });
            return this;
        });
    }
    /**
     * Edit message body.
     * @param {String} body - new body of Message.
     * @returns {Promise<Message|Error|SessionError>}
     */
    updateBody(body) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof body !== 'string') {
                throw new Error('Body <String> is a required parameter for updateBody');
            }
            yield this.services.session.addCommand('editMessage', {
                channelSid: this.channel.sid,
                messageIdx: this.index.toString(),
                text: body
            });
            return this;
        });
    }
    /**
     * Edit message attributes.
     * @param {Object} attributes new attributes for Message.
     * @returns {Promise<Message|Error|SessionError>}
     */
    updateAttributes(attributes) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof attributes === 'undefined') {
                throw new Error('Attributes is a required parameter for updateAttributes');
            }
            else if (attributes.constructor !== Object) {
                throw new Error('Attributes must be a valid JSON object');
            }
            yield this.services.session.addCommand('editMessageAttributes', {
                channelSid: this.channel.sid,
                messageIdx: this.index,
                attributes: JSON.stringify(attributes)
            });
            return this;
        });
    }
}
exports.Message = Message;
/**
 * Fired when the Message's properties or body has been updated.
 * @event Message#updated
 * @type {Message}
 */
