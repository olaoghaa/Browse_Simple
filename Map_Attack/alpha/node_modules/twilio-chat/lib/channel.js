"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const logger_1 = require("./logger");
const members_1 = require("./data/members");
const member_1 = require("./member");
const messages_1 = require("./data/messages");
const util_1 = require("./util");
const log = logger_1.Logger.scope('');
const fieldMappings = {
    attributes: 'attributes',
    createdBy: 'createdBy',
    dateCreated: 'dateCreated',
    dateUpdated: 'dateUpdated',
    friendlyName: 'friendlyName',
    lastConsumedMessageIndex: 'lastConsumedMessageIndex',
    name: 'friendlyName',
    sid: 'sid',
    status: 'status',
    type: 'type',
    uniqueName: 'uniqueName'
};
function parseTime(timeString) {
    try {
        return new Date(timeString);
    }
    catch (e) {
        return null;
    }
}
function filterStatus(status) {
    switch (status) {
        case 'notParticipating':
            return 'known';
        default:
            return status;
    }
}
exports.filterStatus = filterStatus;
/**
 * @classdesc A Channel represents a remote channel of communication between
 * multiple Programmable Chat Clients
 * @property {Object} attributes - The Channel's custom attributes
 * @property {String} createdBy - The identity of the User that created this Channel
 * @property {Date} dateCreated - The Date this Channel was created
 * @property {Date} dateUpdated - The Date this Channel was last updated
 * @property {String} friendlyName - The Channel's name
 * @property {Boolean} isPrivate - Whether the channel is private (as opposed to public)
 * @property {Number} lastConsumedMessageIndex - Index of the last Message the User has consumed in this Channel
 * @property {String} sid - The Channel's unique system identifier
 * @property {('unknown' | 'known' | 'invited' | 'joined' | 'failed')} status - Whether the Channel
 * is 'known' to local Client, Client is 'invited' to or is 'joined' to this Channel
 * @property {('public' | 'private')} type - The Channel's type as a String: ['private', 'public']
 * @property {String} uniqueName - The Channel's unique name (tag)
 * @fires Channel#memberJoined
 * @fires Channel#memberLeft
 * @fires Channel#memberUpdated
 * @fires Channel#messageAdded
 * @fires Channel#messageRemoved
 * @fires Channel#messageUpdated
 * @fires Channel#typingEnded
 * @fires Channel#typingStarted
 * @fires Channel#updated
 */
class Channel extends events_1.EventEmitter {
    constructor(services, descriptor, sid) {
        super();
        let attributes = descriptor.attributes || {};
        let createdBy = descriptor.createdBy;
        let dateCreated = parseTime(descriptor.dateCreated);
        let dateUpdated = parseTime(descriptor.dateUpdated);
        let friendlyName = descriptor.name || descriptor.friendlyName || null;
        let lastConsumedMessageIndex = Number.isInteger(descriptor.lastConsumedMessageIndex) ? descriptor.lastConsumedMessageIndex : null;
        let uniqueName = descriptor.uniqueName || null;
        try {
            JSON.stringify(attributes);
        }
        catch (e) {
            throw new Error('Attributes must be a valid JSON object.');
        }
        this.services = services;
        this.sid = sid;
        this.entityName = descriptor.channel;
        this.state = {
            uniqueName,
            status: 'known',
            type: descriptor.type,
            attributes,
            createdBy,
            dateCreated,
            dateUpdated,
            friendlyName,
            lastConsumedMessageIndex
        };
        this.members = new Map();
        this.membersEntity = new members_1.Members(this, this.services, this.members);
        this.membersEntity.on('memberJoined', this.emit.bind(this, 'memberJoined'));
        this.membersEntity.on('memberLeft', this.emit.bind(this, 'memberLeft'));
        this.membersEntity.on('memberUpdated', this.emit.bind(this, 'memberUpdated'));
        this.messagesEntity = new messages_1.Messages(this, services);
        this.messagesEntity.on('messageAdded', message => this._onMessageAdded(message));
        this.messagesEntity.on('messageUpdated', this.emit.bind(this, 'messageUpdated'));
        this.messagesEntity.on('messageRemoved', this.emit.bind(this, 'messageRemoved'));
    }
    get status() { return this.state.status; }
    get type() { return this.state.type; }
    get uniqueName() { return this.state.uniqueName; }
    get isPrivate() { return this.state.type === 'private'; }
    get friendlyName() { return this.state.friendlyName; }
    get dateUpdated() { return this.state.dateUpdated; }
    get dateCreated() { return this.state.dateCreated; }
    get createdBy() { return this.state.createdBy; }
    get attributes() { return this.state.attributes; }
    get lastConsumedMessageIndex() { return this.state.lastConsumedMessageIndex; }
    /**
     * Load and Subscribe to this Channel and do not subscribe to its Members and Messages.
     * This or _subscribeStreams will need to be called before any events on Channel will fire.
     * @returns {Promise}
     * @private
     */
    _subscribe() {
        if (this.entityPromise) {
            return this.entityPromise;
        }
        return this.entityPromise = this.entityPromise ||
            this.services.syncClient.document({ id: this.entityName, mode: 'open_existing' })
                .then(entity => {
                this.entity = entity;
                this.entity.on('updated', args => { this._update(args.value); });
                this.entity.on('removed', () => this.emit('removed', this));
                this._update(this.entity.value);
                return entity;
            })
                .catch(err => {
                this.entity = null;
                this.entityPromise = null;
                log.error('Failed to get channel object', err);
                throw err;
            });
    }
    /**
     * Load the attributes of this Channel and instantiate its Members and Messages.
     * This or _subscribe will need to be called before any events on Channel will fire.
     * This will need to be called before any events on Members or Messages will fire
     * @returns {Promise}
     * @private
     */
    _subscribeStreams() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this._subscribe();
                log.trace('_subscribeStreams, this.entity.value=', this.entity.value);
                const messagesObjectName = this.entity.value.messages;
                const rosterObjectName = this.entity.value.roster;
                yield Promise.all([
                    this.messagesEntity.subscribe(messagesObjectName),
                    this.membersEntity.subscribe(rosterObjectName)
                ]);
            }
            catch (err) {
                log.error('Failed to subscribe on channel objects', this.sid, err);
                throw err;
            }
        });
    }
    /**
     * Stop listening for and firing events on this Channel.
     * @returns {Promise}
     * @private
     */
    _unsubscribe() {
        return __awaiter(this, void 0, void 0, function* () {
            // Keep our subscription to public channels objects
            if (this.isPrivate && this.entity) {
                yield this.entity.close();
                this.entity = null;
                this.entityPromise = null;
            }
            return Promise.all([
                this.membersEntity.unsubscribe(),
                this.messagesEntity.unsubscribe()
            ]);
        });
    }
    /**
     * Set channel status
     * @private
     */
    _setStatus(status, source) {
        this.statusSource = source;
        if (this.state.status === status) {
            return;
        }
        this.state.status = status;
        if (status === 'joined') {
            this._subscribeStreams();
        }
        else if (status === 'invited') {
            this._subscribe();
        }
        else if (this.entityPromise) {
            this._unsubscribe();
        }
    }
    /**
     * If channel's status update source
     * @private
     * @return {Channels.DataSource}
     */
    _statusSource() {
        return this.statusSource;
    }
    static preprocessUpdate(update, channelSid) {
        try {
            if (typeof update.attributes === 'string') {
                update.attributes = JSON.parse(update.attributes);
            }
            else if (update.attributes) {
                JSON.stringify(update.attributes);
            }
        }
        catch (e) {
            log.warn('Retrieved malformed attributes from the server for channel: ' + channelSid);
            update.attributes = {};
        }
        try {
            if (update.dateCreated) {
                update.dateCreated = new Date(update.dateCreated);
            }
        }
        catch (e) {
            log.warn('Retrieved malformed attributes from the server for channel: ' + channelSid);
            delete update.dateCreated;
        }
        try {
            if (update.dateUpdated) {
                update.dateUpdated = new Date(update.dateUpdated);
            }
        }
        catch (e) {
            log.warn('Retrieved malformed attributes from the server for channel: ' + channelSid);
            delete update.dateUpdated;
        }
    }
    /**
     * Updates local channel object with new values
     * @private
     */
    _update(update) {
        log.trace('_update', update);
        Channel.preprocessUpdate(update, this.sid);
        let updated = false;
        for (let key in update) {
            let localKey = fieldMappings[key];
            if (!localKey) {
                continue;
            }
            if (localKey === fieldMappings.status) {
                if (update.status && update.status != 'unknown') {
                    this.state.status = filterStatus(update.status);
                }
            }
            else if (localKey === fieldMappings.attributes) {
                if (!util_1.isDeepEqual(this.state.attributes, update.attributes)) {
                    this.state.attributes = update.attributes;
                    updated = true;
                }
            }
            else if (update[key] instanceof Date) {
                if (!this.state[localKey] || this.state[localKey].getTime() !== update[key].getTime()) {
                    this.state[localKey] = update[key];
                    updated = true;
                }
            }
            else if (this[localKey] !== update[key]) {
                this.state[localKey] = update[key];
                updated = true;
            }
        }
        if (updated) {
            this.emit('updated', this);
        }
    }
    /**
     * @private
     */
    _onMessageAdded(message) {
        for (let member of this.members.values()) {
            if (member.identity === message.author) {
                member._endTyping();
                break;
            }
        }
        this.emit('messageAdded', message);
    }
    /**
     * Add a participant to the Channel by its Identity.
     * @param {String} identity - Identity of the Client to add
     * @returns {Promise<void|Error|SessionError>}
     */
    add(identity) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!identity || typeof identity !== 'string') {
                throw new Error('Channel.add requires an <String>identity parameter');
            }
            return this.membersEntity.add(identity);
        });
    }
    /**
     * Advance last consumed Channel's Message index to current consumption horizon.
     * Rejects if User is not Member of Channel.
     * Last consumed Message index is updated only if new index value is higher than previous.
     * @param {Number} index - Message index to advance to as last read
     * @returns {Promise<number|Error|SessionError>} resulting unread messages count in the channel
     */
    advanceLastConsumedMessageIndex(index) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!Number.isInteger(index)) {
                throw new Error('Channel.advanceLastConsumedMessageIndex requires an integral <Number>index parameter');
            }
            yield this._subscribeStreams();
            return this.services.consumptionHorizon.advanceLastConsumedMessageIndexForChannel(this.sid, index, this.lastConsumedMessageIndex);
        });
    }
    /**
     * Decline an invitation to the Channel and unsubscribe from its events.
     * @returns {Promise<Channel|SessionError>}
     */
    decline() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.services.session.addCommand('declineInvitation', {
                channelSid: this.sid
            });
            return this;
        });
    }
    /**
     * Delete the Channel and unsubscribe from its events.
     * @returns {Promise<Channel|SessionError>}
     */
    delete() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.services.session.addCommand('destroyChannel', {
                channelSid: this.sid
            });
            return this;
        });
    }
    /**
     * Get the custom attributes of this Channel.<br/>
     *
     * <i>NOTE: {@link Channel}'s <code>attributes</code> property will be empty for public channels until this function is called.</i>
     * @returns {Promise<Object>}
     */
    getAttributes() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._subscribe();
            return this.attributes;
        });
    }
    /**
     * Returns messages from channel using paginator interface.
     * @param {Number} [pageSize=30] Number of messages to return in single chunk
     * @param {Number} [anchor] - Index of newest Message to fetch. From the end by default
     * @param {String} [direction=backwards] - Query direction. By default it query backwards
     *                                         from newer to older. 'forward' will query in opposite direction
     * @returns {Promise<Paginator<Message>>} page of messages
     */
    getMessages(pageSize, anchor, direction) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof anchor !== 'undefined' && !Number.isInteger(anchor)) {
                throw new Error('Anchor should be a valid message index');
            }
            yield this._subscribeStreams();
            return this.messagesEntity.getMessages(pageSize, anchor, direction);
        });
    }
    /**
     * Get a list of all Members joined to this Channel.
     * @returns {Promise<Array<Member>>}
     */
    getMembers() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._subscribeStreams();
            return this.membersEntity.getMembers();
        });
    }
    /**
     * Get channel members count.
     * @returns {Promise<number>}
     */
    getMembersCount() {
        return __awaiter(this, void 0, void 0, function* () {
            let links = yield this.services.session.getSessionLinks();
            let url = new util_1.UriBuilder(links.publicChannelsUrl).path(this.sid).build();
            let response = yield this.services.network.get(url);
            return response.body.members_count;
        });
    }
    /**
     * Get total message count in a channel.
     * @returns {Promise<number>}
     */
    getMessagesCount() {
        return __awaiter(this, void 0, void 0, function* () {
            let links = yield this.services.session.getSessionLinks();
            let url = new util_1.UriBuilder(links.publicChannelsUrl).path(this.sid).build();
            let response = yield this.services.network.get(url);
            return response.body.messages_count;
        });
    }
    /**
     * Get unconsumed messages count for User if he is Member of this Channel.
     * Rejects if User is not Member of Channel.
     * @returns {Promise<number>}
     */
    getUnconsumedMessagesCount() {
        return __awaiter(this, void 0, void 0, function* () {
            let links = yield this.services.session.getSessionLinks();
            let url = new util_1.UriBuilder(links.myChannelsUrl).arg('ChannelSid', this.sid).build();
            let response = yield this.services.network.get(url);
            if (response.body.channels.length) {
                if ((typeof response.body.channels[0].unread_messages_count !== 'undefined') && response.body.channels[0].unread_messages_count != null) {
                    return response.body.channels[0].unread_messages_count;
                }
                else {
                    return null;
                }
            }
            throw new Error('Channel is not in user channels list');
        });
    }
    /**
     * Invite a user to the Channel by their Identity.
     * @param {String} identity - Identity of the user to invite
     * @returns {Promise<void|Error|SessionError>}
     */
    invite(identity) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof identity !== 'string' || !identity.length) {
                throw new Error('Channel.invite requires an <String>identity parameter');
            }
            return this.membersEntity.invite(identity);
        });
    }
    /**
     * Join the Channel and subscribe to its events.
     * @returns {Promise<Channel|SessionError>}
     */
    join() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.services.session.addCommand('joinChannelV2', { channelSid: this.sid });
            return this;
        });
    }
    /**
     * Leave the Channel.
     * @returns {Promise<Channel|SessionError>}
     */
    leave() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.state.status === 'joined') {
                yield this.services.session.addCommand('leaveChannel', { channelSid: this.sid });
            }
            return this;
        });
    }
    /**
     * Remove a Member from the Channel.
     * @param {String} member - identity of member to remove
     * @returns {Promise<void|Error|SessionError>}
     */
    removeMember(member) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!member || (typeof member !== 'string' && !(member instanceof member_1.Member))) {
                throw new Error('Channel.removeMember requires a <String|Member>member parameter.');
            }
            return this.membersEntity.remove(typeof member === 'string' ? member : member.identity);
        });
    }
    /**
     * Send a Message in the Channel.
     * @param {String | FormData | Channel#SendMediaOptions} message - The message body for text message,
     * FormData or MediaOptions for media content
     * @param {Object} messageAttributes - attributes for the message
     * @returns {Promise<String>}
     */
    sendMessage(message, messageAttributes) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof message === 'string') {
                let response = yield this.messagesEntity.send(message, messageAttributes);
                return response.messageId;
            }
            else {
                let response = yield this.messagesEntity.sendMedia(message, messageAttributes);
                return response.messageId;
            }
        });
    }
    /**
     * These options can be passed to {@link Channel#sendMessage}.
     * @typedef {Object} Channel#SendMediaOptions
     * @property {String} contentType - content type of media
     * @property {String | Buffer} media - content to post
     */
    /**
     * Set last consumed Channel's Message index to last known Message's index in this Channel.
     * @returns {Promise<number>} resulting unread messages count in the channel
     */
    setAllMessagesConsumed() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._subscribeStreams();
            let messagesPage = yield this.getMessages(1);
            if (messagesPage.items.length > 0) {
                return this.advanceLastConsumedMessageIndex(messagesPage.items[0].index);
            }
            return Promise.resolve(0);
        });
    }
    /**
     * Set all messages in the channel unread.
     * @returns {Promise<number>} resulting unread messages count in the channel
     */
    setNoMessagesConsumed() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._subscribeStreams();
            return this.services.consumptionHorizon.updateLastConsumedMessageIndexForChannel(this.sid, null);
        });
    }
    /**
     * Send a notification to the server indicating that this Client is currently typing in this Channel.
     * Typing ended notification is sent after a while automatically, but by calling again this method you ensure typing ended is not received.
     * @returns {Promise<void|SessionError>}
     */
    typing() {
        return this.services.typingIndicator.send(this.sid);
    }
    /**
     * Update the Channel's attributes.
     * @param {Object} attributes - The new attributes object
     * @returns {Promise<Channel|Error|SessionError>}
     */
    updateAttributes(attributes) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!attributes) {
                throw new Error('Attributes can\'t be null');
            }
            else if (attributes.constructor !== Object) {
                throw new Error('Attributes must be a valid JSON object.');
            }
            yield this.services.session.addCommand('editAttributes', {
                channelSid: this.sid,
                attributes: JSON.stringify(attributes)
            });
            return this;
        });
    }
    /**
     * Update the Channel's friendlyName.
     * @param {String} name - The new Channel friendlyName
     * @returns {Promise<Channel|SessionError>}
     */
    updateFriendlyName(name) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.state.friendlyName !== name) {
                yield this.services.session.addCommand('editFriendlyName', {
                    channelSid: this.sid,
                    friendlyName: name
                });
            }
            return this;
        });
    }
    /**
     * Set last consumed Channel's Message index to current consumption horizon.
     * @param {Number|null} index - Message index to set as last read.
     * If null provided, then the behavior is identical to {@link Channel#setNoMessagesConsumed}
     * @returns {Promise<number|Error|SessionError>} resulting unread messages count in the channel
     */
    updateLastConsumedMessageIndex(index) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(Number.isInteger(index) || index === null)) {
                throw new Error('Incorrect argument "index": integer number or null expected');
            }
            yield this._subscribeStreams();
            return this.services.consumptionHorizon.updateLastConsumedMessageIndexForChannel(this.sid, index);
        });
    }
    /**
     * Update the Channel's unique name.
     * @param {String} uniqueName - The new Channel uniqueName
     * @returns {Promise<Channel|SessionError>}
     */
    updateUniqueName(uniqueName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.state.uniqueName !== uniqueName) {
                yield this.services.session.addCommand('editUniqueName', {
                    channelSid: this.sid,
                    uniqueName: uniqueName
                });
            }
            return this;
        });
    }
    /**
     * Gets User Descriptors for this channel.
     * @returns {Promise<Paginator<UserDescriptor>>}
     */
    getUserDescriptors() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.services.users.getChannelUserDescriptors(this.sid);
        });
    }
}
exports.Channel = Channel;
/**
 * Fired when a Member has joined the Channel.
 * @event Channel#memberJoined
 * @type {Member}
 */
/**
 * Fired when a Member has left the Channel.
 * @event Channel#memberLeft
 * @type {Member}
 */
/**
 * Fired when a Member's fields has been updated.
 * @event Channel#memberUpdated
 * @type {Member}
 */
/**
 * Fired when a new Message has been added to the Channel.
 * @event Channel#messageAdded
 * @type {Message}
 */
/**
 * Fired when Message is removed from Channel's message list.
 * @event Channel#messageRemoved
 * @type {Message}
 */
/**
 * Fired when an existing Message's fields are updated with new values.
 * @event Channel#messageUpdated
 * @type {Message}
 */
/**
 * Fired when a Member has stopped typing.
 * @event Channel#typingEnded
 * @type {Member}
 */
/**
 * Fired when a Member has started typing.
 * @event Channel#typingStarted
 * @type {Member}
 */
/**
 * Fired when a Channel's attributes or metadata have been updated.
 * During Channel's {@link Client.create | creation and initialization} this event might be fired multiple times
 * for same joined or created Channel as new data is arriving from different sources.
 * @event Channel#updated
 * @type {Channel}
 */
