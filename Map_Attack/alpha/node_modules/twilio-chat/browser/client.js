"use strict";

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _extends2 = require("babel-runtime/helpers/extends");

var _extends3 = _interopRequireDefault(_extends2);

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _promise = require("babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
    return new (P || (P = _promise2.default))(function (resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : new P(function (resolve) {
                resolve(result.value);
            }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = require("events");
var logger_1 = require("./logger");
var configuration_1 = require("./configuration");
var user_1 = require("./user");
exports.User = user_1.User;
var publicchannels_1 = require("./data/publicchannels");
var network_1 = require("./services/network");
var notificationtypes_1 = require("./interfaces/notificationtypes");
var synclist_1 = require("./synclist");
var TwilsockClient = require("twilsock");
var NotificationClient = require("twilio-notifications");
var twilio_transport_1 = require("twilio-transport");
var twilio_sync_1 = require("twilio-sync");
var twilio_ems_client_1 = require("twilio-ems-client");
var twilio_mcs_client_1 = require("twilio-mcs-client");
var session_1 = require("./session");
var channels_1 = require("./data/channels");
var users_1 = require("./data/users");
var typingindicator_1 = require("./services/typingindicator");
var consumptionhorizon_1 = require("./services/consumptionhorizon");
var userchannels_1 = require("./data/userchannels");
var pushnotification_1 = require("./pushnotification");
exports.PushNotification = pushnotification_1.PushNotification;
var util_1 = require("./util");
var log = logger_1.Logger.scope('');
var SDK_VERSION = require('./../package.json').version;
var MSG_NO_TOKEN = 'A valid Twilio token should be provided';

var ClientServices = function ClientServices() {
    (0, _classCallCheck3.default)(this, ClientServices);
};
/**
 * A Client is a starting point to access Twilio Programmable Chat functionality.
 *
 * @property {Map<sid, Channel>} channels - A Map containing all Channels known locally on
 *   the Client. Use {@link Client#getSubscribedChannels} too ensure Channels have loaded before getting a response
 * @property {Client#ConnectionState} connectionState - Client connection state
 * @property {Boolean} reachabilityEnabled - Client reachability state
 * @property {User} user - Information for logged in user
 * @property {String} version - Current version of Chat client
 *
 * @fires Client#connectionStateChanged
 * @fires Client#channelAdded
 * @fires Client#channelInvited
 * @fires Client#channelJoined
 * @fires Client#channelLeft
 * @fires Client#channelRemoved
 * @fires Client#channelUpdated
 * @fires Client#memberJoined
 * @fires Client#memberLeft
 * @fires Client#memberUpdated
 * @fires Client#messageAdded
 * @fires Client#messageRemoved
 * @fires Client#messageUpdated
 * @fires Client#pushNotification
 * @fires Client#typingEnded
 * @fires Client#typingStarted
 * @fires Client#userSubscribed
 * @fires Client#userUnsubscribed
 * @fires Client#userUpdated
 */


var Client = function (_events_1$EventEmitte) {
    (0, _inherits3.default)(Client, _events_1$EventEmitte);

    function Client(token, options) {
        (0, _classCallCheck3.default)(this, Client);

        var _this = (0, _possibleConstructorReturn3.default)(this, (Client.__proto__ || (0, _getPrototypeOf2.default)(Client)).call(this));

        _this.connectionState = 'connecting';
        _this.sessionPromise = null;
        _this.channelsPromise = null;
        _this.version = SDK_VERSION;
        _this.parsePushNotification = Client.parsePushNotification;
        _this.options = options || {};
        _this.options.logLevel = _this.options.logLevel || 'error';
        _this.options.productId = 'ip_messaging';
        // Disable local storage for Sync now
        _this.options.Sync = _this.options.Sync || {};
        if (!_this.options.Sync.enableSessionStorage) {
            _this.options.Sync.enableSessionStorage = false;
        }
        if (!token) {
            throw new Error(MSG_NO_TOKEN);
        }
        log.setLevel(_this.options.logLevel);
        _this.services = new ClientServices();
        _this.config = new configuration_1.Configuration(null, _this.options);
        _this.options.twilsockClient = _this.options.twilsockClient || new TwilsockClient(token, _this.options);
        _this.options.transport = _this.options.transport || new twilio_transport_1.Transport(_this.options.twilsockClient, _this.options);
        _this.options.emsClient = _this.options.emsClient || new twilio_ems_client_1.EmsClient(_this.options);
        _this.options.notificationsClient = _this.options.notificationsClient || new NotificationClient(token, _this.options);
        _this.options.syncClient = _this.options.syncClient || new twilio_sync_1.SyncClient(token, _this.options);
        _this.services.emsClient = _this.options.emsClient;
        _this.services.syncClient = _this.options.syncClient;
        _this.services.transport = _this.options.transport;
        _this.services.twilsockClient = _this.options.twilsockClient;
        _this.services.notificationClient = _this.options.notificationsClient;
        _this.services.session = new session_1.Session(_this.services, _this.config);
        _this.sessionPromise = _this.services.session.initialize();
        _this.services.network = new network_1.Network(_this.config, _this.services);
        _this.services.users = new users_1.Users({
            session: _this.services.session,
            network: _this.services.network,
            syncClient: _this.services.syncClient
        });
        _this.services.users.on('userSubscribed', _this.emit.bind(_this, 'userSubscribed'));
        _this.services.users.on('userUpdated', _this.emit.bind(_this, 'userUpdated'));
        _this.services.users.on('userUnsubscribed', _this.emit.bind(_this, 'userUnsubscribed'));
        _this.services.consumptionHorizon = new consumptionhorizon_1.ConsumptionHorizon(_this.services);
        _this.services.typingIndicator = new typingindicator_1.TypingIndicator(_this.config, {
            transport: _this.services.transport,
            notificationClient: _this.services.notificationClient
        }, _this.getChannelBySid.bind(_this));
        _this.services.syncList = new synclist_1.SyncList(_this.services);
        _this.channels = new channels_1.Channels(_this.services);
        _this.channelsPromise = _this.sessionPromise.then(function () {
            _this.channels.on('channelAdded', _this.emit.bind(_this, 'channelAdded'));
            _this.channels.on('channelRemoved', _this.emit.bind(_this, 'channelRemoved'));
            _this.channels.on('channelInvited', _this.emit.bind(_this, 'channelInvited'));
            _this.channels.on('channelJoined', _this.emit.bind(_this, 'channelJoined'));
            _this.channels.on('channelLeft', _this.emit.bind(_this, 'channelLeft'));
            _this.channels.on('channelUpdated', _this.emit.bind(_this, 'channelUpdated'));
            _this.channels.on('memberJoined', _this.emit.bind(_this, 'memberJoined'));
            _this.channels.on('memberLeft', _this.emit.bind(_this, 'memberLeft'));
            _this.channels.on('memberUpdated', _this.emit.bind(_this, 'memberUpdated'));
            _this.channels.on('messageAdded', _this.emit.bind(_this, 'messageAdded'));
            _this.channels.on('messageUpdated', _this.emit.bind(_this, 'messageUpdated'));
            _this.channels.on('messageRemoved', _this.emit.bind(_this, 'messageRemoved'));
            _this.channels.on('typingStarted', _this.emit.bind(_this, 'typingStarted'));
            _this.channels.on('typingEnded', _this.emit.bind(_this, 'typingEnded'));
            return _this.channels.fetchChannels();
        }).then(function () {
            return _this.channels;
        });
        _this.services.notificationClient.on('connectionStateChanged', function (state) {
            var changedConnectionState = null;
            switch (state) {
                case 'connected':
                    changedConnectionState = 'connected';
                    break;
                case 'rejected':
                    changedConnectionState = 'denied';
                    break;
                case 'denied':
                    changedConnectionState = 'denied';
                    break;
                case 'disconnecting':
                    changedConnectionState = 'disconnecting';
                    break;
                case 'disconnected':
                    changedConnectionState = 'disconnected';
                    break;
                default:
                    changedConnectionState = 'connecting';
            }
            if (changedConnectionState !== _this.connectionState) {
                _this.connectionState = changedConnectionState;
                _this.emit('connectionStateChanged', _this.connectionState);
            }
        });
        _this.fpaToken = token;
        return _this;
    }
    /**
     * Factory method to create Chat client instance.
     *
     * @param {String} token - Access token
     * @param {Client#ClientOptions} options - Options to customize the Client
     * @returns {Promise<Client>}
     */


    (0, _createClass3.default)(Client, [{
        key: "subscribeToPushNotifications",
        value: function subscribeToPushNotifications(channelType) {
            var _this2 = this;

            [notificationtypes_1.NotificationTypes.NEW_MESSAGE, notificationtypes_1.NotificationTypes.ADDED_TO_CHANNEL, notificationtypes_1.NotificationTypes.INVITED_TO_CHANNEL, notificationtypes_1.NotificationTypes.REMOVED_FROM_CHANNEL, notificationtypes_1.NotificationTypes.TYPING_INDICATOR, notificationtypes_1.NotificationTypes.CONSUMPTION_UPDATE].forEach(function (messageType) {
                _this2.services.notificationClient.subscribe(messageType, channelType);
            });
        }
    }, {
        key: "initialize",
        value: function initialize() {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee() {
                var _this3 = this;

                var response, links, options;
                return _regenerator2.default.wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                _context.next = 2;
                                return this.services.emsClient.setToken(this.fpaToken);

                            case 2:
                                response = _context.sent;

                                this.config.updateToken(response.token);
                                _context.next = 6;
                                return this.sessionPromise;

                            case 6:
                                Client.supportedPushChannels.forEach(function (channelType) {
                                    return _this3.subscribeToPushNotifications(channelType);
                                });
                                _context.next = 9;
                                return this.services.session.getSessionLinks();

                            case 9:
                                links = _context.sent;

                                this.services.publicChannels = new publicchannels_1.PublicChannels(this, this.services, links.publicChannelsUrl);
                                this.services.userChannels = new userchannels_1.UserChannels(this, this.services, links.myChannelsUrl);
                                options = (0, _extends3.default)(this.options);

                                options.transport = null;
                                this.services.mcsClient = new twilio_mcs_client_1.McsClient(this.config.token, links.mediaServiceUrl, options);
                                _context.next = 17;
                                return this.services.typingIndicator.initialize();

                            case 17:
                            case "end":
                                return _context.stop();
                        }
                    }
                }, _callee, this);
            }));
        }
        /**
         * Gracefully shutting down library instance.
         * @public
         * @returns {Promise<void>}
         */

    }, {
        key: "shutdown",
        value: function shutdown() {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee2() {
                return _regenerator2.default.wrap(function _callee2$(_context2) {
                    while (1) {
                        switch (_context2.prev = _context2.next) {
                            case 0:
                                _context2.next = 2;
                                return this.services.twilsockClient.disconnect();

                            case 2:
                            case "end":
                                return _context2.stop();
                        }
                    }
                }, _callee2, this);
            }));
        }
        /**
         * Update the token used by the Client and re-register with Programmable Chat services.
         * @param {String} token - Access token
         * @public
         * @returns {Promise<Client>}
         */

    }, {
        key: "updateToken",
        value: function updateToken(token) {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee3() {
                var _this4 = this;

                return _regenerator2.default.wrap(function _callee3$(_context3) {
                    while (1) {
                        switch (_context3.prev = _context3.next) {
                            case 0:
                                log.info('updateToken');

                                if (token) {
                                    _context3.next = 3;
                                    break;
                                }

                                throw new Error(MSG_NO_TOKEN);

                            case 3:
                                if (!(token === this.fpaToken)) {
                                    _context3.next = 5;
                                    break;
                                }

                                return _context3.abrupt("return", this);

                            case 5:
                                return _context3.abrupt("return", this.services.emsClient.setToken(token).then(function (response) {
                                    if (response.status === 'NEW') {
                                        log.error('Can\'t extend token:', response.reason);
                                        throw new Error('Can\'t extend token:' + response.reason);
                                    }
                                    return response.token;
                                }).then(function (rtdToken) {
                                    return _this4.services.twilsockClient.updateToken(token).then(function () {
                                        return _this4.services.syncClient.updateToken(token);
                                    }).then(function () {
                                        return _this4.services.notificationClient.updateToken(token);
                                    }).then(function () {
                                        return _this4.services.mcsClient.updateToken(token);
                                    }).then(function () {
                                        return _this4.sessionPromise;
                                    }).then(function () {
                                        return rtdToken;
                                    });
                                }).then(function (rtdToken) {
                                    _this4.config.updateToken(rtdToken);
                                    _this4.fpaToken = token;
                                    return _this4;
                                }));

                            case 6:
                            case "end":
                                return _context3.stop();
                        }
                    }
                }, _callee3, this);
            }));
        }
        /**
         * Get a known Channel by its SID.
         * @param {String} channelSid - Channel sid
         * @returns {Promise<Channel>}
         */

    }, {
        key: "getChannelBySid",
        value: function getChannelBySid(channelSid) {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee4() {
                var _this5 = this;

                return _regenerator2.default.wrap(function _callee4$(_context4) {
                    while (1) {
                        switch (_context4.prev = _context4.next) {
                            case 0:
                                if (!(!channelSid || typeof channelSid !== 'string')) {
                                    _context4.next = 2;
                                    break;
                                }

                                throw new Error('Client.getChannelBySid requires a <String>channelSid parameter');

                            case 2:
                                return _context4.abrupt("return", this.channels.syncListRead.promise.then(function () {
                                    return _this5.channels.getChannel(channelSid).then(function (channel) {
                                        return channel || _this5.services.publicChannels.getChannelBySid(channelSid).then(function (x) {
                                            return _this5.channels.pushChannel(x);
                                        });
                                    });
                                }));

                            case 3:
                            case "end":
                                return _context4.stop();
                        }
                    }
                }, _callee4, this);
            }));
        }
        /**
         * Get a known Channel by its unique identifier name.
         * @param {String} uniqueName - The unique identifier name of the Channel to get
         * @returns {Promise<Channel>}
         */

    }, {
        key: "getChannelByUniqueName",
        value: function getChannelByUniqueName(uniqueName) {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee5() {
                var _this6 = this;

                return _regenerator2.default.wrap(function _callee5$(_context5) {
                    while (1) {
                        switch (_context5.prev = _context5.next) {
                            case 0:
                                if (!(!uniqueName || typeof uniqueName !== 'string')) {
                                    _context5.next = 2;
                                    break;
                                }

                                throw new Error('Client.getChannelByUniqueName requires a <String>uniqueName parameter');

                            case 2:
                                return _context5.abrupt("return", this.channels.syncListRead.promise.then(function () {
                                    return _this6.services.publicChannels.getChannelByUniqueName(uniqueName).then(function (x) {
                                        return _this6.channels.pushChannel(x);
                                    });
                                }));

                            case 3:
                            case "end":
                                return _context5.stop();
                        }
                    }
                }, _callee5, this);
            }));
        }
        /**
         * Get the current list of all subscribed Channels.
         * @returns {Promise<Paginator<Channel>>}
         */

    }, {
        key: "getSubscribedChannels",
        value: function getSubscribedChannels(args) {
            return this.channelsPromise.then(function (channels) {
                return channels.getChannels(args);
            });
        }
        /**
         * Get the public channels directory content.
         * @returns {Promise<Paginator<ChannelDescriptor>>}
         */

    }, {
        key: "getPublicChannelDescriptors",
        value: function getPublicChannelDescriptors() {
            return this.services.publicChannels.getChannels();
        }
        /**
         * Get the User's (created by, joined or invited to) channels directory content.
         * @returns {Promise<Paginator<ChannelDescriptor>>}
         */

    }, {
        key: "getUserChannelDescriptors",
        value: function getUserChannelDescriptors() {
            return this.services.userChannels.getChannels();
        }
        /**
         * Create a Channel on the server and subscribe to its events.
         * Default options are public Channel type with empty uniqueName and friendlyName.
         * @param {Client#CreateChannelOptions} [options] - Options for the Channel
         * @returns {Promise<Channel>}
         */

    }, {
        key: "createChannel",
        value: function createChannel(options) {
            options = options || {};
            return this.channelsPromise.then(function (channelsEntity) {
                return channelsEntity.addChannel(options);
            });
        }
        /**
         * These options can be passed to {@link Client#createChannel}.
         * @typedef {Object} Client#CreateChannelOptions
         * @property {Object} [attributes] - Any custom attributes to attach to the Channel
         * @property {String} [friendlyName] - The non-unique display name of the Channel
         * @property {Boolean} [isPrivate] - Whether or not this Channel should be visible to uninvited Clients
         * @property {String} [uniqueName] - The unique identity name of the Channel
         */
        /**
         * Registers for push notifications.
         * @param {string} channelType - 'gcm', 'apn' and 'fcm' are supported
         * @param {string} registrationId - Push notification id provided by platform
         */

    }, {
        key: "setPushRegistrationId",
        value: function setPushRegistrationId(channelType, registrationId) {
            if (Client.supportedPushChannels.indexOf(channelType) === -1) {
                throw new Error('Invalid or unsupported channelType: ' + channelType);
            }
            this.services.notificationClient.setPushRegistrationId(registrationId, channelType);
        }
    }, {
        key: "handlePushNotification",

        /**
         * Handle push notification payload parsing and emits event {@link Client#event:pushNotification} on this {@link Client} instance.
         * @param {Object} notificationPayload - Push notification payload
         * @returns {void|Error}
         */
        value: function handlePushNotification(notificationPayload) {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee6() {
                return _regenerator2.default.wrap(function _callee6$(_context6) {
                    while (1) {
                        switch (_context6.prev = _context6.next) {
                            case 0:
                                log.debug('handlePushNotification, notificationPayload=', notificationPayload);
                                this.emit('pushNotification', Client.parsePushNotification(notificationPayload));

                            case 2:
                            case "end":
                                return _context6.stop();
                        }
                    }
                }, _callee6, this);
            }));
        }
        /**
         * Gets user for given identity, if it's in subscribed list - then return the user object from it,
         * if not - then subscribes and adds user to the subscribed list.
         * @param {String} identity - Identity of User
         * @returns {Promise<User>} Fully initialized user
         */

    }, {
        key: "getUser",
        value: function getUser(identity) {
            return this.services.users.getUser(identity);
        }
        /**
         * Gets user descriptor for given identity.
         * @param {String} identity - Identity of User
         * @returns {Promise<UserDescriptor>} User descriptor
         */

    }, {
        key: "getUserDescriptor",
        value: function getUserDescriptor(identity) {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee7() {
                return _regenerator2.default.wrap(function _callee7$(_context7) {
                    while (1) {
                        switch (_context7.prev = _context7.next) {
                            case 0:
                                return _context7.abrupt("return", this.services.users.getUserDescriptor(identity));

                            case 1:
                            case "end":
                                return _context7.stop();
                        }
                    }
                }, _callee7, this);
            }));
        }
        /**
         * @returns {Promise<Array<User>>} List of subscribed User objects
         */

    }, {
        key: "getSubscribedUsers",
        value: function getSubscribedUsers() {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee8() {
                return _regenerator2.default.wrap(function _callee8$(_context8) {
                    while (1) {
                        switch (_context8.prev = _context8.next) {
                            case 0:
                                return _context8.abrupt("return", this.services.users.getSubscribedUsers());

                            case 1:
                            case "end":
                                return _context8.stop();
                        }
                    }
                }, _callee8, this);
            }));
        }
    }, {
        key: "user",

        /**
         * These options can be passed to Client constructor.
         * @typedef {Object} Client#ClientOptions
         * @property {String} [logLevel='error'] - The level of logging to enable. Valid options
         *   (from strictest to broadest): ['silent', 'error', 'warn', 'info', 'debug', 'trace']
         */
        /**
         * Connection state of Client.
         * @typedef {('disconnected'|'disconnecting'|'connecting'|'connected'|'error'|'denied')} Client#ConnectionState
         */
        get: function get() {
            return this.services.users.myself;
        }
    }, {
        key: "reachabilityEnabled",
        get: function get() {
            return this.services.session.reachabilityEnabled;
        }
    }, {
        key: "token",
        get: function get() {
            return this.config.token;
        }
    }], [{
        key: "create",
        value: function create(token, options) {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee9() {
                var client;
                return _regenerator2.default.wrap(function _callee9$(_context9) {
                    while (1) {
                        switch (_context9.prev = _context9.next) {
                            case 0:
                                client = new Client(token, options);
                                _context9.next = 3;
                                return client.initialize();

                            case 3:
                                return _context9.abrupt("return", client);

                            case 4:
                            case "end":
                                return _context9.stop();
                        }
                    }
                }, _callee9, this);
            }));
        }
    }, {
        key: "parsePushNotificationChatData",
        value: function parsePushNotificationChatData(data) {
            var result = {};
            for (var key in Client.supportedPushDataFields) {
                if (typeof data[key] !== 'undefined' && data[key] !== null) {
                    if (key === 'message_index') {
                        if (util_1.parseToNumber(data[key]) !== null) {
                            result[Client.supportedPushDataFields[key]] = Number(data[key]);
                        }
                    } else {
                        result[Client.supportedPushDataFields[key]] = data[key];
                    }
                }
            }
            return result;
        }
        /**
         * Static method for push notification payload parsing. Returns parsed push as {@link PushNotification} object
         * @param {Object} notificationPayload - Push notification payload
         * @returns {PushNotification|Error}
         */

    }, {
        key: "parsePushNotification",
        value: function parsePushNotification(notificationPayload) {
            log.debug('parsePushNotification, notificationPayload=', notificationPayload);
            if (typeof notificationPayload === 'undefined' || notificationPayload === null) {
                throw new Error('Push notification payload should be provided');
            }
            // APNS specifics
            if (typeof notificationPayload.aps !== 'undefined') {
                var body = null;
                var title = null;
                var data = {};
                if (typeof notificationPayload.data !== 'undefined') {
                    data = Client.parsePushNotificationChatData(notificationPayload.data);
                }
                if (!notificationPayload.type) {
                    throw new Error('Provided push notification payload does not contain Programmable Chat push notification type');
                }
                var apsPayload = notificationPayload.aps;
                if (typeof apsPayload.alert === 'string') {
                    body = apsPayload.alert || null;
                } else {
                    body = apsPayload.alert.body || null;
                    title = apsPayload.alert.title || null;
                }
                var badge = apsPayload.badge || null;
                var sound = apsPayload.sound || null;
                var action = apsPayload.category || null;
                return new pushnotification_1.PushNotification({
                    title: title,
                    body: body,
                    sound: sound,
                    badge: badge,
                    action: action,
                    type: notificationPayload.type,
                    data: data
                });
            }
            // FCM/GCM specifics
            if (typeof notificationPayload.data !== 'undefined') {
                var dataPayload = notificationPayload.data;
                if (dataPayload.twi_message_type) {
                    var _data = Client.parsePushNotificationChatData(notificationPayload.data);
                    return new pushnotification_1.PushNotification({
                        title: dataPayload.twi_title || null,
                        body: dataPayload.twi_body || null,
                        sound: dataPayload.twi_sound || null,
                        badge: null,
                        action: dataPayload.twi_action || null,
                        type: dataPayload.twi_message_type,
                        data: _data
                    });
                } else {
                    throw new Error('Provided push notification payload does not contain Programmable Chat push notification type');
                }
            }
            throw new Error('Provided push notification payload is not Programmable Chat notification');
        }
    }]);
    return Client;
}(events_1.EventEmitter);

Client.version = SDK_VERSION;
Client.supportedPushChannels = ['fcm', 'apn', 'gcm'];
Client.supportedPushDataFields = {
    'channel_sid': 'channelSid',
    'message_sid': 'messageSid',
    'message_index': 'messageIndex'
};
exports.Client = Client;
exports.default = Client;
/**
 * Fired when a Channel becomes visible to the Client.
 * Fired for created and not joined private channels and for all type of channels Client has joined or invited to.
 * @event Client#channelAdded
 * @type {Channel}
 */
/**
 * Fired when the Client is invited to a Channel.
 * @event Client#channelInvited
 * @type {Channel}
 */
/**
 * Fired when the Client joins a Channel.
 * @event Client#channelJoined
 * @type {Channel}
 */
/**
 * Fired when the Client leaves a Channel.
 * @event Client#channelLeft
 * @type {Channel}
 */
/**
 * Fired when a Channel is no longer visible to the Client.
 * Only fired for private channels.
 * @event Client#channelRemoved
 * @type {Channel}
 */
/**
 * Fired when a Channel's attributes or metadata have been updated.
 * During Channel's {@link Client.create| creation and initialization} this event might be fired multiple times
 * for same joined or created Channel as new data is arriving from different sources.
 * @event Client#channelUpdated
 * @type {Channel}
 */
/**
 * Fired when a Member has joined the Channel.
 * @event Client#memberJoined
 * @type {Member}
 */
/**
 * Fired when a Member has left the Channel.
 * @event Client#memberLeft
 * @type {Member}
 */
/**
 * Fired when a Member's fields has been updated.
 * @event Client#memberUpdated
 * @type {Member}
 */
/**
 * Fired when a new Message has been added to the Channel on the server.
 * @event Client#messageAdded
 * @type {Message}
 */
/**
 * Fired when Message is removed from Channel's message list.
 * @event Client#messageRemoved
 * @type {Message}
 */
/**
 * Fired when an existing Message's fields are updated with new values.
 * @event Client#messageUpdated
 * @type {Message}
 */
/**
 * Fired when a Member has stopped typing.
 * @event Client#typingEnded
 * @type {Member}
 */
/**
 * Fired when a Member has started typing.
 * @event Client#typingStarted
 * @type {Member}
 */
/**
 * Fired when the Client is subscribed to a User.
 * @event Client#userSubscribed
 * @type {User}
 */
/**
 * Fired when the Client is unsubscribed from a User.
 * @event Client#userUnsubscribed
 * @type {User}
 */
/**
 * Fired when the User's properties or reachability status have been updated.
 * @event Client#userUpdated
 * @type {User}
 */
/**
 * Fired when Client's connection state has been changed.
 * @event Client#connectionStateChanged
 * @type {Client#ConnectionState}
 */
/**
 * Fired when client received (and parsed) push notification via one of push channels (apn, gcm, fcm).
 * @event Client#pushNotification
 * @type {PushNotification}
 */