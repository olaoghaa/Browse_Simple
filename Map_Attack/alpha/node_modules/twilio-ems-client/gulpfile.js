const gulp = require('gulp');
const mocha = require('gulp-mocha');
const istanbul = require('gulp-istanbul');
const eslint = require('gulp-eslint');
const babel = require('gulp-babel');
const runSequence = require('run-sequence');
const del = require('del');
const cheerio = require('cheerio');
const tap = require('gulp-tap');
const isparta = require('isparta');
const typescript = require('gulp-typescript');

const pkg = require('./package');

var cp = require('child_process');
var jsdoc = 'node_modules/jsdoc/jsdoc.js';

const product = {
  source: {
    name: pkg.name + '.js',
    lib: 'src/*.js'
  },
  compiled: {
    dir: 'lib',
    lib: 'lib/*.js'
  },
  browser: {
    dir: 'browser'
  },
  packaged: {
    dir: 'dist',
    name: pkg.name + '.js',
    minified: pkg.name + '.min.js'
  },
  license: 'LICENSE'
};

const tests = {
  lint: {
    files: [
      'src/*.js',
      '!src/utils.js',
      '!src/jsondiff.js',
      'gulpfile.js'
    ]
  },
  unit: {
    files: 'test/unit/spec/*.ts',
    index: 'test/unit/index.ts'
  },
  integration: {
    files: 'test/integration/**/*.ts',
    index: 'test/integration/index.ts'
  }
};

const coverage = {
  dir: product.packaged.dir + '/coverage'
};

const docs = {
  dir: product.packaged.dir + '/docs',
  conf: 'jsdoc.json',
  files: [
    './src/client.ts',
  ],
  publicConstructors: ['Client'],
  privateConstructors: []
};

gulp.task('lint', function() {
  return gulp.src(tests.lint.files)
      .pipe(eslint())
      .pipe(eslint.format())
      .pipe(eslint.failAfterError());
});

gulp.task('istanbul-setup', ['build-node'], function() {
  return gulp.src([product.source.lib])
    .pipe(istanbul({
      instrumenter: isparta.Instrumenter,
      includeUntested: true
    }))
    .pipe(istanbul.hookRequire());
});

gulp.task('unit-test', ['istanbul-setup'], function() {
  return gulp.src(tests.unit.index, { read: false })
    .pipe(mocha({
      compilers: 'ts:ts-node/register',
      reporter: 'spec'
    }))
    .pipe(istanbul.writeReports({
      dir: coverage.dir,
      reporters: ['cobertura', 'lcov', 'text'],
      reportOpts: { dir: coverage.dir }
    }));
});

gulp.task('integration-test', function() {
  return gulp.src(tests.integration.index, { read: false })
    .pipe(mocha({
      compilers: 'ts:ts-node/register',
      reporter: 'spec',
      timeout: 5000
    }));
});

gulp.task('build-node', function() {
  const project = typescript.createProject('tsconfig.json');
  return project.src()
    .pipe(project())
    .pipe(gulp.dest('lib'));
});

gulp.task('build-browser', ['build-node'], function() {
  return gulp.src(product.compiled.lib)
    .pipe(babel())
    .pipe(gulp.dest('browser'));
});

gulp.task('generate-doc', function(cb) {
  cp.exec(['node', jsdoc,
          '-d', docs.dir,
          '-c', docs.conf,
          docs.files.join(' '),
          './README.md',
          '-t ./node_modules/ink-docstrap/template'].join(' '), cb);
});

gulp.task('prettify-doc', function() {
  return gulp.src(docs.dir + '/*.html')
    .pipe(tap(function(file) {
      var $ = cheerio.load(file.contents.toString());
      var filename = file.path.slice(file.base.length);
      var className = filename.split('.html')[0];
      var div;

      // Prefix public constructors.
      if (docs.publicConstructors.indexOf(className) > -1) {
        div = $('.container-overview');
        var name = $('h4.name', div);
        name.html(name.html().replace(/new /, 'new <span style="color: #999">Twilio.EMS.</span>'));
      }

      // Remove private constructors.
      if (docs.privateConstructors.indexOf(className) > -1) {
        div = $('.container-overview');
        $('h2', div).remove();
        $('h4.name', div).remove();
        $('div.description', div).remove();
        $('h5:contains(Parameters:)', div).remove();
        $('table.params', div).remove();
      }

      file.contents = new Buffer($.html());
      return file;
    }))
  .pipe(gulp.dest(docs.dir));
});

gulp.task('doc', function(done) {
  runSequence('generate-doc', 'prettify-doc', done);
});

gulp.task('clean', function() {
  return del([
    product.compiled.dir,
    product.browser.dir,
    product.packaged.dir,
  ]);
});

gulp.task('build', ['build-node', 'build-browser']);

gulp.task('default', function(done) {
  runSequence(
    'clean',
    'lint',
    'unit-test',
    'build',
    'doc',
    done
  );
});

