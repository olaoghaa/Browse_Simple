"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const operation_retrier_1 = require("operation-retrier");
const configuration_1 = require("./configuration");
const logger_1 = require("./logger");
const persistentState_1 = require("./persistentState");
const twilio_transport_1 = require("twilio-transport");
function createPromise() {
    let pd = { promise: null, resolve: null, reject: null };
    pd.promise = new Promise((resolve, reject) => {
        pd.resolve = resolve;
        pd.reject = reject;
    });
    return pd;
}
class TokenRequest {
    constructor() { }
}
/**
 * Client for Twilio Endpoint Management service (EMS).
 */
class EmsClient extends events_1.EventEmitter {
    /**
     * @param config Configuration structure
     */
    constructor(config) {
        super();
        config = config || {};
        config.transport = config.transport || new twilio_transport_1.Transport(config.twilsockClient || null);
        this.state = new persistentState_1.PersistentState();
        this.config = new configuration_1.default(config);
        this.twilsock = config.twilsockClient;
        this.transport = config.transport;
    }
    /**
     * Set new FPA token
     * @param fpaToken <String> new FPA token to use
     * @return Promise<EMSClient#TokenInfo>
     */
    setToken(fpaToken) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.currentFpaToken !== fpaToken) {
                this.currentFpaToken = fpaToken;
                let oldTokenRequest = this.currentTokenRequest;
                this.currentTokenRequest = this.establishToken(fpaToken);
                this.notifyRejected(oldTokenRequest);
            }
            return this.currentTokenRequest.promise;
        });
    }
    notifyRejected(request) {
        if (request) {
            setTimeout(() => request.reject(new Error('Operation has been cancelled by next token')), 0);
        }
    }
    establishToken(fpaToken) {
        let tokenRequest = new TokenRequest();
        let promise = new Promise((resolve, reject) => {
            this.establishTokenImpl(fpaToken).then(resolve).catch(reject);
            tokenRequest.resolve = resolve;
            tokenRequest.reject = reject;
        });
        tokenRequest.promise = promise;
        return tokenRequest;
    }
    ;
    establishTokenImpl(fpaToken) {
        return __awaiter(this, void 0, void 0, function* () {
            return new operation_retrier_1.default({ min: 500, max: 2000 })
                .run(() => this.requestRtdToken(fpaToken))
                .then(res => {
                if (res.status != 'ok') {
                    throw res.exception;
                }
                if (this.currentFpaToken !== fpaToken) {
                    // user has already set new token. ignoring
                    return;
                }
                this.state.continuationToken = res.response.continuation_token;
                const rtdToken = res.response.twilio_rtd_token;
                if (res.response.status.status === 'NEW') {
                    this.emit('tokenCreated', rtdToken);
                }
                else {
                    this.emit('tokenUpdated', rtdToken);
                }
                this.emit('token', rtdToken);
                let response = {
                    token: res.response.twilio_rtd_token,
                    ttl: res.response.ttl,
                    status: res.response.status.status,
                    reason: (res.response.status.reason || null),
                    identity: (res.response.identity || null),
                    accountSid: res.response.account_sid,
                    serviceSids: res.response.instance_sids,
                };
                this.emit('response', response);
                return response;
            })
                .catch(e => {
                logger_1.default.error(e);
                throw e;
            });
        });
    }
    requestRtdToken(fpaToken) {
        return __awaiter(this, void 0, void 0, function* () {
            const headers = { 'Content-Type': 'application/json' };
            const body = {
                fpa_token: fpaToken,
                continuation_token: this.state.continuationToken
            };
            logger_1.default.debug('Token request', body);
            try {
                let response = yield this.transport.post(this.config.url, headers, body);
                logger_1.default.debug('Token response:', response);
                return { status: 'ok', token: fpaToken, response: response.body };
            }
            catch (e) {
                if (e.status === 401 || e.status === 403) {
                    // map transport error
                    // TODO: remove me when transport fixed
                    if (!(e instanceof Error)) {
                        if (e.body) {
                            e = new Error(e.body.message);
                        }
                        else if (e.description) {
                            e = new Error(e.description);
                        }
                    }
                    return { status: 'denied', exception: e, token: null, response: null };
                }
                throw e;
            }
        });
    }
}
exports.EmsClient = EmsClient;
/**
 * This structure describes an RTD token
 * @typedef {Object} EMSClient#TokenInfo
 * @property {String} token - RTD token generated for given FPA token
 * @property {Number} ttl - ttl to calculate expiration token time
 * @property {String} status - Indicates did server generated new token or extended existing. Valid values are ['NEW', 'UPDATED'].
 * @property {String} reason - If service issued a new RTD token, this field describes a reason
 */
// for backward compatibility
const EMSClient = EmsClient;
exports.EMSClient = EMSClient;
exports.default = EMSClient;
