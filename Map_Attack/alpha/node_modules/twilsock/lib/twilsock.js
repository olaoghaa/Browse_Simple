'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _freeze = require('babel-runtime/core-js/object/freeze');

var _freeze2 = _interopRequireDefault(_freeze);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _defineProperties = require('babel-runtime/core-js/object/define-properties');

var _defineProperties2 = _interopRequireDefault(_defineProperties);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var _uuid = require('uuid');

var _uuid2 = _interopRequireDefault(_uuid);

var _backoff = require('backoff');

var _backoff2 = _interopRequireDefault(_backoff);

var _javascriptStateMachine = require('javascript-state-machine');

var _javascriptStateMachine2 = _interopRequireDefault(_javascriptStateMachine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var WebSocket = global.WebSocket || global.MozWebSocket || require('ws');

var ACTIVITY_CHECK_INTERVAL = 5000;
var ACTIVITY_TIMEOUT = 43000;

var INIT_TIMEOUT = 5000;
var UPDATE_TIMEOUT = 5000;
var DISCONNECTING_TIMEOUT = 3000;

function byteLength(s) {
  var escstr = encodeURIComponent(s);
  var binstr = escstr.replace(/%([0-9A-F]{2})/g, function (match, p1) {
    return String.fromCharCode('0x' + p1);
  });
  return binstr.length;
}

function stringToUint8Array(s) {
  var escstr = encodeURIComponent(s);
  var binstr = escstr.replace(/%([0-9A-F]{2})/g, function (match, p1) {
    return String.fromCharCode('0x' + p1);
  });
  var ua = new Uint8Array(binstr.length);
  Array.prototype.forEach.call(binstr, function (ch, i) {
    ua[i] = ch.charCodeAt(0);
  });
  return ua;
}

function uint8ArrayToString(ua) {
  var binstr = Array.prototype.map.call(ua, function (ch) {
    return String.fromCharCode(ch);
  }).join('');
  var escstr = binstr.replace(/(.)/g, function (m, p) {
    var code = p.charCodeAt(0).toString(16).toUpperCase();
    if (code.length < 2) {
      code = '0' + code;
    }
    return '%' + code;
  });
  return decodeURIComponent(escstr);
}

function getMagic(buffer) {
  var strMagic = '';
  var idx = 0;
  for (; idx < buffer.length; ++idx) {
    var chr = String.fromCharCode(buffer[idx]);
    strMagic += chr;
    if (chr === '\r') {
      idx += 2;
      break;
    }
  }

  var magics = strMagic.split(' ');
  return {
    size: idx,
    protocol: magics[0],
    version: magics[1],
    headerSize: Number(magics[2])
  };
}

/**
 * Makes sure that body is properly stringified
 */
function preparePayload(payload) {
  switch (typeof payload === 'undefined' ? 'undefined' : (0, _typeof3.default)(payload)) {
    case 'undefined':
      return '';
    case 'object':
      return (0, _stringify2.default)(payload);
    default:
      return payload;
  }
}

/**
 * @param {Uint8Array} array
 * @returns {Object}
 */
function getJsonObject(array) {
  var str = uint8ArrayToString(array);
  try {
    return JSON.parse(str);
  } catch (e) {
    _logger2.default.error('failed to parse input: ', str);
    throw e;
  }
}

/**
 * @class TwilsockChannel
 * @classdesc Twilsock connection
 *
 * @param config
 */

var TwilsockChannel = function (_EventEmitter) {
  (0, _inherits3.default)(TwilsockChannel, _EventEmitter);

  function TwilsockChannel(config) {
    (0, _classCallCheck3.default)(this, TwilsockChannel);

    var _this = (0, _possibleConstructorReturn3.default)(this, (TwilsockChannel.__proto__ || (0, _getPrototypeOf2.default)(TwilsockChannel)).call(this));

    if (config.logLevel) {
      _logger2.default.setLevel(config.logLevel);
    }

    var backoff = _backoff2.default.exponential({
      randomisationFactor: 0.2,
      initialDelay: 2 * 1000,
      maxDelay: 2 * 60 * 1000
    });

    backoff.on('ready', function () {
      _this._retry();
    });
    _this.on('reply', function (reply) {
      _this._processReply(reply);
    });

    (0, _defineProperties2.default)(_this, {
      _config: { value: config },
      _transportReady: { value: false, writable: true },
      _disconnectedPromiseResolve: { value: null, writable: true },
      _backoffDefault: { value: backoff },
      _backoff: { value: backoff, writable: true },
      _fsm: { value: null, writable: true },
      _watchTimer: { value: null, writable: true },
      _timestamp: { value: 0, writable: true },
      _socket: { value: null, writable: true },
      _activeToken: { value: null, writable: true },
      activeToken: { enumerable: true, get: function get() {
          return _this._activeToken;
        } },
      state: { enumberable: true, get: function get() {
          return _this._getState();
        } },
      isConnected: { enumberable: true, get: function get() {
          return _this._isConnected();
        } },
      _activeRequests: { value: new _map2.default() },
      _disconnectingTimer: { value: null, writable: true },
      _isDeferredUpdate: { value: false, writable: true }
    });

    _this._fsm = _javascriptStateMachine2.default.create({
      initial: 'disconnected',
      events: [{ name: 'userConnect', from: ['disconnected', 'rejected'], to: 'connecting' }, { name: 'userConnect', from: ['connecting', 'connected'] }, // ignore event
      { name: 'userDisconnect', from: ['connecting', 'initialising', 'connected', 'updating', 'retrying', 'rejected', 'waitSocketClosed', 'waitOffloadSocketClosed'], to: 'disconnecting' }, { name: 'userRetry', from: ['retrying'], to: 'connecting' }, { name: 'socketConnected', from: ['connecting'], to: 'initialising' }, { name: 'socketClosed', from: ['connecting', 'initialising', 'connected', 'updating', 'error', 'waitOffloadSocketClosed'], to: 'retrying' }, { name: 'socketClosed', from: ['disconnecting'], to: 'disconnected' }, { name: 'socketClosed', from: ['waitSocketClosed'], to: 'disconnected' }, { name: 'socketClosed', from: ['rejected'], to: 'rejected' }, { name: 'initSuccess', from: ['initialising'], to: 'connected' }, { name: 'initError', from: ['initialising'], to: 'error' }, { name: 'tokenRejected', from: ['initialising', 'updating'], to: 'rejected' }, { name: 'protocolError', from: ['initialising', 'connected', 'updating'], to: 'error' }, { name: 'receiveClose', from: ['initialising', 'connected', 'updating'], to: 'waitSocketClosed' }, { name: 'receiveOffload', from: ['initialising', 'connected', 'updating'], to: 'waitOffloadSocketClosed' }, { name: 'unsupportedProtocol', from: ['initialising', 'connected', 'updating'], to: 'unsupported' }, { name: 'receiveFatalClose', from: ['initialising', 'connected', 'updating'], to: 'unsupported' }, { name: 'userUpdateToken', from: ['disconnected', 'rejected', 'connecting', 'retrying'], to: 'connecting' }, { name: 'userUpdateToken', from: ['connected'], to: 'updating' }, { name: 'updateSuccess', from: ['updating'], to: 'connected' }, { name: 'updateError', from: ['updating'], to: 'error' }],
      callbacks: {
        onconnecting: function onconnecting() {
          _this._startWatchdogTimer();
          _this._setupSocket();
          _this.emit('connecting');
        },
        onenterinitialising: function onenterinitialising() {
          _this._sendInit();
        },
        onleaveinitialising: function onleaveinitialising() {
          _this._cancelInit();
        },
        onenterupdating: function onenterupdating() {
          _this._sendUpdate();
        },
        onleaveupdating: function onleaveupdating() {
          _this._cancelUpdate();
        },
        onenterretrying: function onenterretrying() {
          _this._initRetry();
          _this.emit('connecting');
        },
        onenterconnected: function onenterconnected() {
          _this._resetBackoff();
          _this._onConnected();
        },
        onuserUpdateToken: function onuserUpdateToken() {
          _this._resetBackoff();
        },
        ontokenRejected: function ontokenRejected() {
          _this._resetBackoff();
          _this._closeSocket();
          _this._finalizeSocket();
        },
        onuserDisconnect: function onuserDisconnect() {
          _this._closeSocket();
        },
        onenterdisconnecting: function onenterdisconnecting() {
          _this._startDisconnectTimer();
        },
        onleavedisconnecting: function onleavedisconnecting() {
          _this._cancelDisconnectTimer();
        },
        onenterwaitSocketClosed: function onenterwaitSocketClosed() {
          _this._startDisconnectTimer();
        },
        onleavewaitSocketClosed: function onleavewaitSocketClosed() {
          _this._cancelDisconnectTimer();
        },
        onenterwaitOffloadSocketClosed: function onenterwaitOffloadSocketClosed() {
          _this._startDisconnectTimer();
        },
        onleavewaitOffloadSocketClosed: function onleavewaitOffloadSocketClosed() {
          _this._cancelDisconnectTimer();
        },
        ondisconnected: function ondisconnected() {
          _this._resetBackoff();
          _this._finalizeSocket();
        },
        onreceiveClose: function onreceiveClose(event, from, to, args) {
          _logger2.default.debug('onreceiveClose: ', args);
          _this._onCloseReceived(args);
        },
        onreceiveOffload: function onreceiveOffload(event, from, to, args) {
          _logger2.default.debug('onreceiveoffload: ', args);
          _this._modifyBackoff(args.body);
          _this._onCloseReceived(args.status);
        },
        onunsupported: function onunsupported() {
          _this._closeSocket();
          _this._finalizeSocket();
        },
        onerror: function onerror() {
          _this._closeSocket();
          _this._finalizeSocket();
        },
        onenterstate: function onenterstate(event, from, to) {
          _this._changeState(event, from, to);
        }
      },
      error: function error() {
        _logger2.default.warn('FSM: unexpected transition', arguments);
      }
    });

    return _this;
  }

  (0, _createClass3.default)(TwilsockChannel, [{
    key: '_changeState',
    value: function _changeState(event, from, to) {
      var _this2 = this;

      _logger2.default.debug('FSM: ', event, ': ', from, '>>', to);

      this.emit('stateChanged', this.state);

      if (this._isDeferredUpdate) {
        this._isDeferredUpdate = false;
        setTimeout(function () {
          _this2.updateToken();
        }, 0);
      }
    }
  }, {
    key: '_resetBackoff',
    value: function _resetBackoff() {
      _logger2.default.trace('_resetBackoff');
      this._backoff = this._backoffDefault;
      this._backoff.reset();
    }
  }, {
    key: '_modifyBackoff',
    value: function _modifyBackoff(body) {
      var _this3 = this;

      _logger2.default.trace('_modifyBackoff', body);

      var backoffPolicy = body ? body.backoff_policy : null;

      if (backoffPolicy) {
        var min = backoffPolicy.reconnect_min_ms || 2 * 1000;
        var max = backoffPolicy.reconnect_max_ms || 2 * 60 * 1000;

        _logger2.default.debug('new backoff policy', min, max);

        this._backoff = _backoff2.default.exponential({
          randomisationFactor: 0.2,
          initialDelay: min,
          maxDelay: max
        });
        this._backoff.on('ready', function () {
          _this3._retry();
        });
      }
    }
  }, {
    key: '_startDisconnectTimer',
    value: function _startDisconnectTimer() {
      var _this4 = this;

      _logger2.default.trace('_startDisconnectTimer');

      if (this._disconnectingTimer) {
        clearTimeout(this._disconnectingTimer);
        this._disconnectingTimer = null;
      }

      this._disconnectingTimer = setTimeout(function () {
        _logger2.default.debug('disconnecting is timed out');
        _this4._closeSocket();
      }, DISCONNECTING_TIMEOUT);
    }
  }, {
    key: '_cancelDisconnectTimer',
    value: function _cancelDisconnectTimer() {
      _logger2.default.trace('_cancelDisconnectTimer');

      if (this._disconnectingTimer) {
        clearTimeout(this._disconnectingTimer);
        this._disconnectingTimer = null;
      }
    }
  }, {
    key: '_processReply',
    value: function _processReply(reply) {
      _logger2.default.debug('receive reply:', reply);

      var request = this._activeRequests.get(reply.id);
      if (request) {
        clearTimeout(request.timeout);
        this._activeRequests.delete(reply.id);

        switch (request.reqType) {
          case 'init':
            if (reply.status.code >= 200 && reply.status.code < 300) {
              this._fsm.initSuccess(reply.body);
            } else if (reply.status.code === 401 || reply.status.code === 403) {
              this._fsm.tokenRejected(reply.status);
            } else if (reply.status.code === 429) {
              this._modifyBackoff(reply.body);
              this._fsm.initError(reply.status);
            } else {
              this._fsm.initError(reply.status);
            }
            break;
          case 'update':
            if (reply.status.code >= 200 && reply.status.code < 300) {
              this._fsm.updateSuccess(reply.body);
            } else if (reply.status.code === 401 || reply.status.code === 403) {
              this._fsm.tokenRejected(reply.status);
            } else if (reply.status.code === 429) {
              this._modifyBackoff(reply.body);
              this._fsm.updateError(reply.status);
            } else {
              this._fsm.updateError(reply.status);
            }
            break;
          default:
            _logger2.default.error('unexpected reply');
        }
      }
    }
  }, {
    key: '_storeRequest',
    value: function _storeRequest(id, type, timeoutMs) {
      var _this5 = this;

      _logger2.default.trace('_storeRequest');

      var requestDescriptor = {
        reqType: type,
        timeout: setTimeout(function () {
          _logger2.default.debug('request', type, ': ', id, 'is timed out');

          if (type !== 'init' && type !== 'update') {
            _logger2.default.error('unknown request type', type);
          }

          _this5._closeSocket();
        }, timeoutMs)
      };

      this._activeRequests.set(id, requestDescriptor);
    }

    /**
     * Checks if connection established
     * @public
     */

  }, {
    key: '_isConnected',
    value: function _isConnected() {
      return this.state === TwilsockChannel.state.CONNECTED && this._socket && this._socket.readyState === 1;
    }

    /**
     * @returns {Number} Connection state
     * @public
     */

  }, {
    key: '_getState',
    value: function _getState() {
      if (!this._fsm) {
        return TwilsockChannel.state.DISCONNECTED;
      }

      switch (this._fsm.current) {
        case 'connecting':
        case 'initialising':
        case 'retrying':
        case 'error':
          return TwilsockChannel.state.CONNECTING;
        case 'updating':
        case 'connected':
          return TwilsockChannel.state.CONNECTED;
        case 'rejected':
          return TwilsockChannel.state.REJECTED;
        case 'disconnecting':
        case 'waitSocketClosed':
        case 'waitOffloadSocketClosed':
          return TwilsockChannel.state.DISCONNECTING;
        case 'disconnected':
        default:
          return TwilsockChannel.state.DISCONNECTED;
      }
    }
  }, {
    key: '_initRetry',
    value: function _initRetry() {
      _logger2.default.trace('_initRetry');

      this._backoff.backoff();
    }
  }, {
    key: '_retry',
    value: function _retry() {
      _logger2.default.trace('_retry');

      this._socket = null;
      this._activeToken = null;
      this._fsm.userRetry();
    }
  }, {
    key: '_onConnected',
    value: function _onConnected() {
      this.emit('connected');
    }
  }, {
    key: '_finalizeSocket',
    value: function _finalizeSocket() {
      _logger2.default.trace('_finalizeSocket');

      this._stopWatchdogTimer();
      this._onDisconnected();

      if (this._disconnectedPromiseResolve) {
        var resolve = this._disconnectedPromiseResolve;
        this._disconnectedPromiseResolve = null;
        resolve();
      }
    }
  }, {
    key: '_onDisconnected',
    value: function _onDisconnected() {
      this._socket = null;
      this._activeToken = null;
      this.emit('disconnected');
    }
  }, {
    key: '_setupSocket',
    value: function _setupSocket() {
      _logger2.default.trace('_setupSocket:', this._config.token);

      var self = this;
      var uri = this._config.twilsockUri;

      _logger2.default.debug('try to connect to:', uri);

      var socket = new WebSocket(uri);
      socket.binaryType = 'arraybuffer';

      socket.onopen = function () {
        _logger2.default.info('socket opened');
        self._fsm.socketConnected();
      };

      socket.onclose = function (e) {
        _logger2.default.info('socket closed', e);
        self._fsm.socketClosed();
      };

      socket.onerror = function (e) {
        _logger2.default.error('error: ', e);
      };

      socket.onmessage = function (message) {
        _logger2.default.trace('data: ', message.data);

        var fieldMargin = 2;

        var dataView = new Uint8Array(message.data);
        var magic = getMagic(dataView);
        if (magic.protocol !== 'TWILSOCK' || magic.version !== 'V3.0') {
          _logger2.default.error('unsupported protocol: ' + magic.protocol + ' ver ' + magic.version);
          self._fsm.unsupportedProtocol();
          return;
        }

        var header = null;
        try {
          header = getJsonObject(dataView.subarray(magic.size, magic.size + magic.headerSize));
        } catch (e) {
          _logger2.default.error('failed to parse message header', e, message);
          self._fsm.protocolError();
          return;
        }
        _logger2.default.trace('message received: ', header);

        var payload = null;
        if (header.payload_size > 0) {
          var payloadOffset = fieldMargin + magic.size + magic.headerSize;
          var payloadSize = header.payload_size;

          if (!header.hasOwnProperty('payload_type') || header.payload_type.indexOf('application/json') === 0) {
            try {
              payload = getJsonObject(dataView.subarray(payloadOffset, payloadOffset + payloadSize));
            } catch (e) {
              _logger2.default.error('failed to parse message body', e, message);
              self._fsm.protocolError();
              return;
            }
          } else if (header.payload_type.indexOf('text/plain') === 0) {
            payload = uint8ArrayToString(dataView.subarray(payloadOffset, payloadOffset + payloadSize));
          }
        }

        self._updateActivityTimestamp();

        if (header.method === 'notification') {
          self._confirmReceiving(header);
          self.emit('message', header.message_type, payload);
        } else if (header.method === 'reply') {
          self.emit('reply', {
            id: header.id,
            status: header.status,
            header: header,
            body: payload
          });
        } else if (header.method === 'ping') {
          self._confirmReceiving(header);
        } else if (header.method === 'close') {
          _logger2.default.trace('connection close initated by server');
          self._confirmReceiving(header);

          if (header.status.code === 308) {
            _logger2.default.info('connection has been offloaded');
            self._fsm.receiveOffload({ status: header.status.status, body: payload });
          } else if (header.status.code === 406) {
            // Not acceptable message
            _logger2.default.error('connection has been rejected because server can not parse protocol');
            self._fsm.receiveFatalClose();
          } else if (header.status.code === 417) {
            // Protocol error
            _logger2.default.info('connection has been rejected because server could not understand client`s reply');
            self._fsm.receiveFatalClose(header.status.status);
          } else if (header.status.code === 410) {
            // Expired connection
            _logger2.default.info('connection has expired');
            self._fsm.receiveClose(header.status.status);
          } else if (header.status.code === 401) {
            // Authentication fail
            _logger2.default.info('connection is not authenticate');
            self._fsm.receiveClose(header.status.status);
          } else {
            _logger2.default.error('unexpected close: ', header.status);
            // Try to reconnect
            self._fsm.receiveOffload({ status: header.status.status, body: null });
          }
        }
      };

      this._activeToken = this._config.token;
      this._socket = socket;
    }
  }, {
    key: '_sendInit',
    value: function _sendInit() {
      _logger2.default.trace('_sendInit');

      var header = {
        id: _uuid2.default.v4(),
        method: 'init',
        token: this._activeToken
      };

      this._sendPacket(header);
      this._storeRequest(header.id, 'init', INIT_TIMEOUT);
    }
  }, {
    key: '_sendUpdate',
    value: function _sendUpdate() {
      _logger2.default.trace('_sendUpdate');

      var header = {
        id: _uuid2.default.v4(),
        method: 'update',
        token: this._activeToken
      };

      this._sendPacket(header);
      this._storeRequest(header.id, 'update', UPDATE_TIMEOUT);
    }
  }, {
    key: '_cancelInit',
    value: function _cancelInit() {
      _logger2.default.trace('_cancelInit');

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(this._activeRequests), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _step$value = (0, _slicedToArray3.default)(_step.value, 2),
              id = _step$value[0],
              request = _step$value[1];

          if (request && request.reqType === 'init') {
            clearTimeout(request.timeout);
            this._activeRequests.delete(id);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: '_cancelUpdate',
    value: function _cancelUpdate() {
      _logger2.default.trace('_cancelUpdate');

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (0, _getIterator3.default)(this._activeRequests), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _step2$value = (0, _slicedToArray3.default)(_step2.value, 2),
              id = _step2$value[0],
              request = _step2$value[1];

          if (request && request.reqType === 'update') {
            clearTimeout(request.timeout);
            this._activeRequests.delete(id);
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }

    /**
     * Should be called for each message to confirm it received
     */

  }, {
    key: '_confirmReceiving',
    value: function _confirmReceiving(messageHeader) {
      _logger2.default.trace('_confirmReceiving');

      var header = {
        method: 'reply',
        id: messageHeader.id,
        payload_type: 'application/json', // eslint-disable-line camelcase
        status: { code: 200, status: 'OK' }
      };

      try {
        this._sendPacket(header);
      } catch (e) {
        _logger2.default.debug('failed to confirm packet receiving', e);
      }
    }

    /**
     * Prepare binary packet and send it over the network
     */

  }, {
    key: '_sendPacket',
    value: function _sendPacket(header, payload) {
      var payloadString = preparePayload(payload);

      header.payload_size = byteLength(payloadString); // eslint-disable-line camelcase
      var headerString = (0, _stringify2.default)(header) + '\r\n';
      var magicString = 'TWILSOCK V3.0 ' + (byteLength(headerString) - 2) + '\r\n';

      _logger2.default.debug('send request:', magicString + headerString + payloadString);

      var message = stringToUint8Array(magicString + headerString + payloadString);

      try {
        this._socket.send(message.buffer);
      } catch (e) {
        _logger2.default.info('failed to send ', header, e);
        _logger2.default.info(e.stack);
        throw e;
      }
    }

    /**
     * Shutdown connection
     * @private
     */

  }, {
    key: '_closeSocket',
    value: function _closeSocket() {
      _logger2.default.trace('_closeSocket');

      if (this._socket) {
        this._socket.onopen = null;
        this._socket.onclose = null;
        this._socket.onerror = null;
        this._socket.onmessage = null;

        this._socket.close();
      }
      this._fsm.socketClosed();
    }

    /**
     * Initiate the twilsock connection
     * If already connected, it does nothing
     */

  }, {
    key: 'connect',
    value: function connect() {
      _logger2.default.trace('connect');
      this._fsm.userConnect();
    }

    /**
     * Retry the twilsock connection
     */

  }, {
    key: 'reconnect',
    value: function reconnect() {
      _logger2.default.trace('reconnect');
      this._resetBackoff();
      this._fsm.userRetry();
    }

    /**
     * Check twilsock is in retry state
     */

  }, {
    key: 'isRetrying',
    value: function isRetrying() {
      return this._fsm.current === 'retrying';
    }

    /**
     * Close twilsock connection
     * If already disconnected, it does nothing
     */

  }, {
    key: 'disconnect',
    value: function disconnect() {
      var _this6 = this;

      _logger2.default.trace('disconnect');

      if (this._fsm.is('disconnected')) {
        return _promise2.default.resolve();
      }

      return new _promise2.default(function (resolve) {
        _this6._disconnectedPromiseResolve = resolve;
        _this6._fsm.userDisconnect();
      });
    }

    /**
     * Update fpa token for twilsock connection
     */

  }, {
    key: 'updateToken',
    value: function updateToken() {
      _logger2.default.trace('updateToken:', this._config.token);

      if (this._fsm.current === 'initialising' || this._fsm.current === 'updating' || this._fsm.current === 'waitSocketClosed' || this._fsm.current === 'waitOffloadSocketClosed') {

        _logger2.default.debug('defer updateToken because of', this._fsm.current, 'is in progress');
        this._isDeferredUpdate = true;
        return;
      }

      this._isDeferredUpdate = false;

      this._activeToken = this._config.token;
      this._fsm.userUpdateToken();
    }

    /**
     * Send upstream message
     * @returns {String} id of sent message
     */

  }, {
    key: 'sendUpstreamMessage',
    value: function sendUpstreamMessage(address, headers, body) {
      var id = _uuid2.default.v4();

      var httpRequest = {
        host: address.host,
        path: address.path,
        method: address.method
      };

      if (address.hasOwnProperty('params')) {
        httpRequest.params = address.params;
      }

      /* eslint-disable camelcase */
      var twilsockHeader = {
        method: 'message',
        id: id,
        http_request: httpRequest
      };

      if (headers) {
        twilsockHeader.http_request.headers = headers;
      }

      if (headers && headers.hasOwnProperty('Content-Type')) {
        twilsockHeader.payload_type = headers['Content-Type'];
      }

      this._sendPacket(twilsockHeader, body);
      return id;
      /* eslint-enable camelcase */
    }
  }, {
    key: 'send',
    value: function send(header, body) {
      header.id = header.id || _uuid2.default.v4();
      this._sendPacket(header, body);
      return header.id;
    }

    /**
     * @private
     */

  }, {
    key: '_onCloseReceived',
    value: function _onCloseReceived(reason) {
      _logger2.default.trace('_onCloseReceived');
      _logger2.default.info('connection closed by server, reason is', reason);

      // Waiting for server close connection. All others events are skipped
      if (this._socket) {
        this._socket.onopen = null;
        this._socket.onerror = null;
        this._socket.onmessage = null;
      }
    }

    /**
     * @private
     */

  }, {
    key: '_startWatchdogTimer',
    value: function _startWatchdogTimer() {
      var _this7 = this;

      _logger2.default.trace('_startWatchdogTimer');

      this._timestamp = Date.now();
      this._watchTimer = setInterval(function () {
        if (Date.now() - _this7._timestamp > ACTIVITY_TIMEOUT && _this7._socket) {
          _this7._socket.close();
        }
      }, ACTIVITY_CHECK_INTERVAL);
    }

    /**
     * @private
     */

  }, {
    key: '_stopWatchdogTimer',
    value: function _stopWatchdogTimer() {
      _logger2.default.trace('_stopWatchdogTimer');

      clearInterval(this._watchTimer);
    }

    /**
     * @private
     */

  }, {
    key: '_updateActivityTimestamp',
    value: function _updateActivityTimestamp() {
      _logger2.default.trace('_updateActivityTimestamp');

      this._timestamp = Date.now();
    }
  }]);
  return TwilsockChannel;
}(_events2.default);
/**
 * Enum for connection state values.
 * @readonly
 * @enum {number}
 */


exports.default = TwilsockChannel;
TwilsockChannel.state = {
  DISCONNECTED: 'disconnected',
  CONNECTING: 'connecting',
  CONNECTED: 'connected',
  DISCONNECTING: 'disconnecting',
  ERROR: 'error',
  REJECTED: 'rejected'
};
(0, _freeze2.default)(TwilsockChannel.state);

(0, _freeze2.default)(TwilsockChannel);
module.exports = exports['default'];