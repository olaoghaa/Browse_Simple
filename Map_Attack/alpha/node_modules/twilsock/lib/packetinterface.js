'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _defineProperties = require('babel-runtime/core-js/object/define-properties');

var _defineProperties2 = _interopRequireDefault(_defineProperties);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var REQUEST_TIMEOUT = 30000;

function isHttpSuccess(code) {
  return code >= 200 && code < 300;
}

function isHttpReply(packet) {
  return packet && packet.header && packet.header.http_status;
}

var PacketInterface = function () {
  function PacketInterface(socket) {
    var _this = this;

    (0, _classCallCheck3.default)(this, PacketInterface);

    (0, _defineProperties2.default)(this, {
      _activeRequests: { value: new _map2.default() },
      _socket: { value: socket }
    });

    this._socket.on('reply', this._processReply.bind(this));
    this._socket.on('disconnected', function () {
      _this._activeRequests.forEach(function (descriptor) {
        clearTimeout(descriptor.timeout);
        descriptor.reject(new Error('Twilsock disconnected'));
      });
      _this._activeRequests.clear();
    });
  }

  (0, _createClass3.default)(PacketInterface, [{
    key: '_processReply',
    value: function _processReply(reply) {
      var request = this._activeRequests.get(reply.id);
      if (request) {
        clearTimeout(request.timeout);
        this._activeRequests.delete(reply.id);

        setTimeout(function () {
          // User shouldn't intercept connection handling, thus making it asynchronous
          if (!isHttpSuccess(reply.status.code)) {
            request.reject(new Error('Transport failure: ' + reply.status.status));
          } else if (isHttpReply(reply) && !isHttpSuccess(reply.header.http_status.code)) {
            request.reject({
              status: reply.header.http_status.code,
              description: reply.header.http_status.status,
              body: reply.body
            });
          } else {
            request.resolve(reply);
          }
        }, 0);
      }
    }
  }, {
    key: '_storeRequest',
    value: function _storeRequest(id, resolve, reject) {
      var requestDescriptor = {
        resolve: resolve,
        reject: reject,
        timeout: setTimeout(function () {
          _logger2.default.debug('request', id, 'is timed out');
          reject(new Error('Twilsock: request timeout: ' + id));
        }, REQUEST_TIMEOUT)
      };
      this._activeRequests.set(id, requestDescriptor);
    }
  }, {
    key: 'send',
    value: function send(address, headers, body) {
      var _this2 = this;

      return new _promise2.default(function (resolve, reject) {
        if (!_this2._socket.isConnected) {
          _logger2.default.info('Can not send upstream message. Twilsock is not in connected state');
          reject(new Error('Twilsock is not connected'));
        }

        var id = _this2._socket.sendUpstreamMessage(address, headers, body);
        _logger2.default.trace('message sent: ', { id: id, address: address, headers: headers, body: body });
        _this2._storeRequest(id, resolve, reject);
      });
    }
  }, {
    key: 'putNotificationContext',
    value: function putNotificationContext(contextId, context) {
      var _this3 = this;

      return new _promise2.default(function (resolve, reject) {
        if (!_this3._socket.isConnected) {
          _logger2.default.info('Can not send put notification context. Twilsock is not in connected state');
          reject(new Error('Twilsock is not connected'));
        }

        var header = { method: 'put_notification_ctx', notification_ctx_id: contextId }; // eslint-disable-line camelcase
        var id = _this3._socket.send(header, context);
        _this3._storeRequest(id, resolve, reject);
      });
    }
  }, {
    key: 'deleteNotificationContext',
    value: function deleteNotificationContext(contextId) {
      var _this4 = this;

      return new _promise2.default(function (resolve, reject) {
        if (!_this4._socket.isConnected) {
          _logger2.default.info('Can not send delete notification context. Twilsock is not in connected state');
          reject(new Error('Twilsock is not connected'));
        }

        var packet = { method: 'delete_notification_ctx', notification_ctx_id: contextId }; // eslint-disable-line camelcase
        var id = _this4._socket.send(packet);
        _this4._storeRequest(id, resolve, reject);
      });
    }
  }, {
    key: 'shutdown',
    value: function shutdown() {
      this._activeRequests.forEach(function (descriptor) {
        clearTimeout(descriptor.timeout);
        descriptor.reject(new Error('Twilsock: request cancelled by user'));
      });
      this._activeRequests.clear();
    }
  }]);
  return PacketInterface;
}();

exports.default = PacketInterface;
module.exports = exports['default'];